/// Return the CSS color for a palette color name.
///
/// @param {String} $color-name - The name of the colour to get.
/// @param {String} $from ['o-colors'] - Which component or project to get the colour from (optional).
@function oColorsByName($color-name, $from: 'o-colors') {
	// Validate arguments are strings.
	@if(type-of($color-name) != 'string') {
		@return _error('`$color-name` should be a string but found "#{inspect($color-name)}" of type "#{type-of($color-name)}".');
	}
	@if(type-of($from) != 'string') {
		@return _error('`$from` should be a string but found "#{inspect($from)}" of type "#{type-of($from)}".');
	}
	// Error when the color name is not found.
	// Get the namespaced color name.
	$namespaced-color-name: '#{$from}-#{$color-name}';
	$color-map: map-get($_o-colors-palette, $namespaced-color-name);
	@if (not $color-map) {
		@return _error('The color "#{inspect($color-name)}" set by "#{inspect($from)}" does not exist.');
	}

	// Get color details.
	$color: map-get($color-map, 'color');
	$meta: map-get($color-map, 'meta');

	// Output any deprecation notice.
	$deprecated: map-get($meta, 'deprecated');
	$already-warned: index($_o-colors-deprecation-warnings-output, $namespaced-color-name) != null;
	@if $deprecated and not $already-warned {
		$deprecation-message: 'The color "#{$color-name}" from "#{$from}" is deprecated for the "#{oBrandGetCurrentBrand()}" palette, and will be removed in the next major.';
		// Append any custom deprecation message.
		$deprecation-message: if(type-of($deprecated) != 'string', $deprecation-message, $deprecation-message + ' ' + $deprecated);
		// Output warning.
		$_o-colors-deprecation-warnings-output: append($_o-colors-deprecation-warnings-output, $namespaced-color-name) !global;
		@warn $deprecation-message;
	}

	@return $color;
}

/// Return the defined palette color for a use case / property combination
///
/// @param {String} $usecase - The name of the usecase, e.g. 'page'.
/// @param {String} $property - The usecase property e.g. 'text', 'background', 'border', 'outline'
/// @param {Color|Null} $fallback - The value to return if the usecase isn't found.
/// @param {String|Color|Null} - The fallback if the usecase is not found. Either a colour, palette colour string, or `null` (note: the default is `false` to indicate no fallback).
/// @return {Color} - The usecase colour.
@function oColorsByUsecase($usecase, $property, $fallback: false, $from: 'o-colors') {
	// Find the colour name of the requested usecase. Fallback to null so we can
	// handle a fallback colour or colour name if no usecase is found.
	$color: oColorsNameByUsecase($usecase, $property, $fallback: null, $from: $from);
	// If no usecase was found and null was given as a fallback return null.
	@if $color == null and $fallback == null {
		@return null;
	}
	// If no usecase was found and a colour was given as a fallback return the fallback.
	@if $color == null and type-of($fallback) == 'color' {
		@return $fallback;
	}
	// If no usecase was found and a colour name was given as a fallback find the colour from the name.
	@if $color == null and type-of($fallback) == 'string' {
		@return oColorsByName($fallback);
	}

	@return oColorsByName($color);
}

/// Return the defined palette color name for a use case / property combination
///
/// @param {String} $usecase - The name of the usecase, e.g. 'page'.
/// @param {String} $property - The usecase property e.g. 'text', 'background', 'border', 'outline'
/// @param {Color|Null} $fallback - The value to return if the usecase isn't found.
/// @param {String|Null} - The fallback name if the usecase is not found. Either a palette colour string or `null` (note: the default is `false` to indicate no fallback).
/// @return {String} - The usecase colour name.
@function oColorsNameByUsecase($usecase, $property, $fallback: false, $from: 'o-colors') {
	// Validate usecase is a string.
	@if(type-of($usecase) != 'string') {
		@return _error('`$usecase` should be a string but found ' +
		'"#{inspect($usecase)}" of type "#{type-of($usecase)}".');
	}

	// Validate from is a string.
	@if(type-of($from) != 'string') {
		@return _error('`$from` should be a string but found ' +
		'"#{inspect($from)}" of type "#{type-of($from)}".');
	}

	// Validate property is allowed.
	$valid-properties: ('text', 'background', 'border', 'outline');
	@if(not index($valid-properties, $property)) {
		@return _error('`$property` should be one of ' +
		'"#{inspect($valid-properties)}" but found "#{inspect($property)}".');
	}

	// Validate fallback is a colour or null.
	// `false` is used as a default to indicate the user has not passed a fallback.
	$valid-fallback: type-of($fallback) == 'string' or type-of($fallback) == 'null';
	@if($fallback != false and not $valid-fallback) {
		@return _error('`$fallback` should be a valid colour name or `null`, ' +
		'found "#{inspect($fallback)}".');
	}

	// Get properties for usecase. Error if none are found.
	$namespaced-usecase: '#{$from}-#{$usecase}';
	$config: map-get($_o-colors-usecases, $namespaced-usecase);
	@if($config == null) {
		@return if($valid-fallback, $fallback, _error(
			'The colour usecase #{inspect($usecase)} couldn\'t be found ' +
			'for #{inspect($from)}'
		));
	}

	// Get colour for usecase property. If none are found look for the property
	// specifically, see if the usecase has set a colour for `all` properties.
	// Error if no colour is found.
	$colors: map-get($config, 'colors');
	$color: map-get($colors, $property);
	$color: if($color, $color, map-get($colors, all));
	@if($color == null) {
		@return if($valid-fallback, $fallback, _error(
			'The colour usecase property #{inspect($property)} couldn\'t ' +
			'be found within the #{inspect($from)} #{inspect($usecase)} usecase.'
		));
	}

	// Output any deprecation warnings, if not already.
	$opts: map-get($config, 'opts');
	$deprecated: if(type-of($opts) == 'map', map-get($opts, 'deprecated'), null);
	$deprecated-key: 'usecase-#{$namespaced-usecase}-#{$property}';
	@if(not index($_o-colors-deprecation-warnings-output, $deprecated-key)) {
		@if (type-of($deprecated) == 'string') {
			@warn 'Color usecase "#{inspect($usecase)}" from #{inspect($from)} is deprecated ' +
			'(property "#{inspect($property)}" was requested): #{inspect($deprecated)}';
		}
		@if (type-of($deprecated) == 'map' and map-has-key($deprecated, $property)) {
			@warn 'The "#{inspect($property)}" property of "#{inspect($from)}" ' +
			'"#{inspect($usecase)}" color usecase is deprecated: ' +
			'#{inspect(map-get($deprecated, $property))}';
		}
		$_o-colors-deprecation-warnings-output: append($_o-colors-deprecation-warnings-output, $deprecated-key) !global;
	}

	@return $color;
}

/// Returns a brighter or darker tone of a colour, where the hue remains
/// the same but the saturation and luminance changes.
///
/// Not all our colours allow tones. If a colour cannot be toned an error is
/// thrown. You may however mix the colour with another supported colour.
/// @see oColorsMix
///
/// @param {String} $color-name - the name of the color to be shaded
/// @param {Number} $brightness - the brightness value of the new color, 0-100
@function oColorsGetTone($color-name, $brightness) {
	$color: oColorsByName($color-name);
	$hue: hue($color);
	// Find a tone from a base of 90% saturation.
	// The reason for this is not known. It's here to preserve the tones we
	// currently have. The base starting used to be configured per colour
	// and may once have differed from colour to colour.
	$saturation: 90;

	// Validate the given colour allows different tones.
	$has-tone-config: map-has-key($_o-colors-default-palette-tones, $color-name);
	@if (not $has-tone-config) {
		@return _error('"#{$color-name}" does not support tones. ' +
			'Consider using a mix instead e.g: ' +
			'`oColorsMix(\'#{$color-name}\', $percentage: #{$brightness})`');
	}

	// Validate brightness.
	@if(type-of($brightness) != 'number' or $brightness > 100 or $brightness < 0) {
		@return _error('"$brightness" must be a number between 0 and 100.');
	}

	@if $brightness == 0 {
		@return hsla(0, 0, 0, 1);
	} @else {
		$hsl-luminance: ($brightness/2) * (2 - ($saturation/100));
		$hsl-saturation: ($brightness * $saturation) / if($hsl-luminance < 50, $hsl-luminance * 2, 200 - $hsl-luminance * 2);

		@return hsla($hue, $hsl-saturation, $hsl-luminance, 1);
	}
}

/// Figure out if a given colour is a tone. If it is a tone return the original
/// colour name and its tone value, otherwise return null.
///
/// @example Get the tone value of 'claret-80'
///    $tone-details: oColorsGetToneDetails('claret-80');
///    $color: map-get($tone-details, 'color'); // claret
///    $value: map-get($tone-details, 'value'); // 80
///
/// @param {String} $color - the palette colour hex or color name e.g. 'claret-80'
/// @return {Map|Null} - the details of the given tone e.g. ('color': 'claret', 'value': 80)					)
@function oColorsGetToneDetails($color) {
	$color: if(type-of($color) == 'string', oColorsByName($color), $color);
	$hue: hue($color);
	@each $tone-color, $tone-config in $_o-colors-default-palette-tones {
		// Check its hex against tone to find the tone value.
		$value: 0;
		@while $value <= 100 {
			@if(inspect(oColorsGetTone($tone-color, $value)) == inspect($color)) {
				@return (
					'color': $tone-color,
					'value': $value
				);
			}
			$value: $value + 1;
		}
	}
	// No tone matched.
	@return null;
}

/// Returns a color based on the background context and base color
/// at the supplied percentage
///
/// @param {String|Color} $color [black] - palette name of color
/// @param {String|Color} $background [paper] - palette name of background color
/// @param {Number} $percentage [60] - percentage opacity of the foreground color over the background
@function oColorsMix($color: 'black', $background: oColorsByUsecase('page', 'background'), $percentage: 80) {
	$base: if(type-of($background) == 'string', oColorsByName($background), $background);
	$mixer: if(type-of($color) == 'string', oColorsByName($color), $color);

	@if type-of($base) != color {
		@return _error("'#{inspect($background)}' is not a valid base color.");
	}

	@if type-of($mixer) != color {
		@return _error("'#{inspect($color)}' is not a valid mixing color.");
	}

	@return mix($mixer, $base, $percentage);
}

/// Returns a text color based on the background and
/// an opacity percentage the color should appear at
///
/// @param {Color|String} $background - the palette name or hex of the background the text will appear on
/// @param {Number} $opacity [100] - the opacity percentage the text color should appear at
/// @param {String|Null} $minimum-contrast ['aa-normal'] - the minimum contrast ratio standard between the background and the returned text color, one of: aa-normal, aa-large, aaa-normal, aaa-large. See [WCAG 2.1 guidelines](https://www.w3.org/TR/WCAG21/#contrast-minimum). If the contrast ratio is too low to meet the selected guideline an error is thrown. Set to `null` to remove contrast checking and never throw an error.
@function oColorsGetTextColor($background, $opacity: 90, $minimum-contrast: 'aa-normal') {
	// Get background hex if palette colour name has been given.
	$background-name: $background;
	$background: if(type-of($background) == 'string', oColorsByName($background), $background);

	// Contrast values. See https://www.w3.org/TR/WCAG21/#contrast-minimum
	$contrast-levels: (
		'aa-normal': 4.5,
		'aa-large': 3,
		'aaa-normal': 7,
		'aaa-large': 4.5
	);

	// Validate arguments.
	@if($minimum-contrast != null and not map-has-key($contrast-levels, $minimum-contrast)) {
		@return _error('The minimum contrast must by one of "#{map-keys($contrast-levels)}" '+
		'or `null`. Found "#{inspect($minimum-contrast)}".');
	}

	@if type-of($background) != color {
		@return _error("'#{inspect($background)}' is not a valid color. To get a text color, please supply a valid hex code or color name for the background color'");
	}

	@if type-of($opacity) != 'number' {
		@return _error("'#{inspect($opacity)}' is not a valid opacity, set to a number.'");
	}

	$contrast-ratio-aim: map-get(
		$contrast-levels,
		if($minimum-contrast, $minimum-contrast, 'aa-normal')
	);

	// Calculate text colour for background and opacity.
	$base-color-a: if(oColorsColorBrightness($background) < 65%, 'white', 'black');
	$text-color-a: oColorsMix($base-color-a, $background, $opacity);
	$contrast-ratio-a: oColorsGetContrastRatio($text-color-a, $background);
	@if $contrast-ratio-a > $contrast-ratio-aim {
		@return $text-color-a;
	}

	// Switch the base colour if the first attempt did not pass contrast checks.
	$base-color-b: if($base-color-a == 'black', 'white', 'black');
	$text-color-b: oColorsMix($base-color-b, $background, $opacity);
	$contrast-ratio-b: oColorsGetContrastRatio($text-color-b, $background);
	@if $contrast-ratio-b > $contrast-ratio-aim {
		@return $text-color-b;
	}

	// Error if neither base colour produced a text colour of high enough contrast.
	@if $minimum-contrast != null {
		$best-contrast-ratio: if($contrast-ratio-a > $contrast-ratio-b, $contrast-ratio-a, $contrast-ratio-b);
		@return _error(
			'The text colour generated for #{inspect($background-name)} at ' +
			'#{inspect($opacity)}% opacity has a contrast ratio of ' +
			'"#{inspect($best-contrast-ratio)}" and does not pass the WCAG 2.1 ' +
			'#{$minimum-contrast} required contrast ratio of at least ' +
			'#{$contrast-ratio-aim}:1. Update the `$minimum-contrast` argument ' +
			'if a lower contrast is acceptable.'
		);
	}

	@return if($contrast-ratio-a > $contrast-ratio-b, $text-color-a, $text-color-b);
}

/// Work out the brightness value in % of a color
/// From: https://gist.github.com/jlong/f06f5843104ee10006fe
///
/// @param {Color} $color - color value to get brightness from (either a CSS colour or o-colors palette colour name)
@function oColorsColorBrightness($color) {
	$color: if(type-of($color) == 'string', oColorsByName($color), $color);

	$red-magic-number: 241;
	$green-magic-number: 691;
	$blue-magic-number: 68;

	$brightness-divisor: $red-magic-number + $green-magic-number + $blue-magic-number;

	// Extract color components
	$red-component: red($color);
	$green-component: green($color);
	$blue-component: blue($color);

	// Calculate a brightness value in 3d color space between 0 and 255
	$number: sqrt((($red-component * $red-component * $red-magic-number) + ($green-component * $green-component * $green-magic-number) + ($blue-component * $blue-component * $blue-magic-number)) / $brightness-divisor);

	// Convert to percentage and return
	@return 100% * ($number / 255);
}

/// Returns the luminance of `$color` as a float (between 0 and 1)
/// 1 is pure white, 0 is pure black.
/// From: https://css-tricks.com/snippets/sass/luminance-color-function/
/// @param {String|Color} $color -  The colour to return a luminance for (either a CSS colour or o-colors palette colour name)
/// @return {Number}
@function oColorsColorLuminance($color) {
	$color: if(type-of($color) == 'string', oColorsByName($color), $color);

	$colors: (
		'red': red($color),
		'green': green($color),
		'blue': blue($color)
	);

	@each $name, $value in $colors {
		$adjusted: 0;
		$value: $value / 255;

		@if $value < 0.03928 {
			$value: $value / 12.92;
		} @else {
			$value: ($value + 0.055) / 1.055;
			$value: pow($value, 2.4);
		}

		$colors: map-merge($colors, ($name: $value));
	}

	@return (map-get($colors, 'red') * 0.2126) + (map-get($colors, 'green') * 0.7152) + (map-get($colors, 'blue') * 0.0722);
}

/// Calculate the contrast ratio between two colours.
///
/// @param {String|Color} $color-a - first colour to compare (either a CSS colour or o-colors palette colour name)
/// @param {String|Color} $color-b - second colour to compare (either a CSS colour or o-colors palette colour name)
/// Based on the JS in https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/contrast-ratio.js
@function oColorsGetContrastRatio($color-a, $color-b) {
	$l1: oColorsColorLuminance($color-a) + 0.05;
	$l2: oColorsColorLuminance($color-b) + 0.05;

	$ratio: $l1 / $l2;

	@if $l2 > $l1 {
		$ratio: 1 / $ratio;
	}

	$ratio: _oColorsPreciseFloor($ratio);

	@return $ratio;
}

/// Return color names and the component/project name they're from.
/// @return {List} - A list of maps with palette color details e.g. `(('name': 'paper', 'from': 'o-colors'), ('name': 'storm', 'from': 'o-example'))`
@function oColorsGetPalette() {
	$public-palette-details: ();

	@each $name, $color-map in $_o-colors-palette {
		$details: (
			'name': map-get($color-map, 'name'),
			'from': map-get($color-map, 'from')
		);
		$public-palette-details: append($public-palette-details, $details);
	}

	@return $public-palette-details;
}

/// @access private
@function _oColorsPreciseFloor($number, $decimals: 2) {
	$multiplier: pow(10, $decimals);
	@return floor($number * $multiplier) / $multiplier;
}

/// Allows for errors to be tested in dev environments
// Code from: https://github.com/oddbird/true/issues/92
/// @access private
@function _error($message, $capture: $_o-colors-test-environment) {
	@if $capture {
		@return 'ERROR: #{$message}';
	}

	@error('#{$message}');
};
