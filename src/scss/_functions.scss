/// Return the CSS color for a palette color name.
///
/// @param {String} $color-name - The name of the colour to get.
/// @param {String} $from ['o-colors'] - Which component or project to get the colour from (optional).
@function oColorsByName($color-name, $from: 'o-colors') {
	// Validate arguments are strings.
	@if(type-of($color-name) != 'string') {
		@return _error('`$color-name` should be a string but found "#{inspect($color-name)}" of type "#{type-of($color-name)}".');
	}
	@if(type-of($from) != 'string') {
		@return _error('`$from` should be a string but found "#{inspect($from)}" of type "#{type-of($from)}".');
	}
	// Error when the color name is not found.
	// Get the namespaced color name.
	$namespaced-color-name: '#{$from}-#{$color-name}';
	$color-map: map-get($_o-colors-palette, $namespaced-color-name);
	@if (not $color-map) {
		@return _error('The color "#{inspect($color-name)}" set by "#{inspect($from)}" does not exist.');
	}

	// Get color details.
	$color: map-get($color-map, 'color');
	$meta: map-get($color-map, 'meta');

	// Output any deprecation notice.
	$deprecated: map-get($meta, 'deprecated');
	$already-warned: index($_o-colors-deprecation-warnings-output, $namespaced-color-name) != null;
	@if $deprecated and not $already-warned {
		$deprecation-message: 'The color "#{$color-name}" from "#{$from}" is deprecated for the "#{oBrandGetCurrentBrand()}" palette, and will be removed in the next major.';
		// Append any custom deprecation message.
		$deprecation-message: if(type-of($deprecated) != 'string', $deprecation-message, $deprecation-message + ' ' + $deprecated);
		// Output warning.
		$_o-colors-deprecation-warnings-output: append($_o-colors-deprecation-warnings-output, $namespaced-color-name) !global;
		@warn $deprecation-message;
	}

	@return $color;
}

/// Return the defined palette color for a use case / property combination
///
/// @param {String} $usecase - The name of the usecase, e.g. 'page'.
/// @param {String} $property - The usecase property e.g. 'text', 'background', 'border', 'outline'
/// @param {Color|Null} $fallback - The value to return if the usecase isn't found.
/// @param {String|Color|Null} - The fallback if the usecase is not found. Either a colour, palette colour string, or `null` (note: the default is `false` to indicate no fallback).
/// @return {Color} - The usecase colour.
@function oColorsByUsecase($usecase, $property, $fallback: false, $from: 'o-colors') {
	// Validate usecase is a string.
	@if(type-of($usecase) != 'string') {
		@return _error('`$usecase` should be a string but found ' +
		'"#{inspect($usecase)}" of type "#{type-of($usecase)}".');
	}

	// Validate from is a string.
	@if(type-of($from) != 'string') {
		@return _error('`$from` should be a string but found ' +
		'"#{inspect($from)}" of type "#{type-of($from)}".');
	}

	// Validate property is allowed.
	$valid-properties: ('text', 'background', 'border', 'outline');
	@if(not index($valid-properties, $property)) {
		@return _error('`$property` should be one of ' +
		'"#{inspect($valid-properties)}" but found "#{inspect($property)}".');
	}

	// Validate fallback is a colour or null.
	// `false` is used as a default to indicate the user has not passed a fallback.
	$fallback: if(type-of($fallback) == 'string', oColorsByName($fallback), $fallback);
	$valid-fallback: type-of($fallback) == 'color' or type-of($fallback) == 'null';
	@if($fallback != false and not $valid-fallback) {
		@return _error('`$fallback` should be a valid colour or `null`, ' +
		'found "#{inspect($fallback)}".');
	}

	// Get properties for usecase. Error if none are found.
	$namespaced-usecase: '#{$from}-#{$usecase}';
	$config: map-get($_o-colors-usecases, $namespaced-usecase);
	@if($config == null) {
		@return if($valid-fallback, $fallback, _error(
			'The colour usecase #{inspect($usecase)} couldn\'t be found ' +
			'for #{inspect($from)}'
		));
	}

	// Get colour for usecase property. If none are found look for the property
	// specifically, see if the usecase has set a colour for `all` properties.
	// Error if no colour is found.
	$colors: map-get($config, 'colors');
	$color: map-get($colors, $property);
	$color: if($color, $color, map-get($colors, all));
	@if($color == null) {
		@return if($valid-fallback, $fallback, _error(
			'The colour usecase property #{inspect($property)} couldn\'t ' +
			'be found within the #{inspect($from)} #{inspect($usecase)} usecase.'
		));
	}

	// Output any deprecation warnings, if not already.
	$opts: map-get($config, 'opts');
	$deprecated: if(type-of($opts) == 'map', map-get($opts, 'deprecated'), null);
	$deprecated-key: 'usecase-#{$namespaced-usecase}-#{$property}';
	@if(not index($_o-colors-deprecation-warnings-output, $deprecated-key)) {
		@if (type-of($deprecated) == 'string') {
			@warn 'Color usecase "#{inspect($usecase)}" from #{inspect($from)} is deprecated ' +
			'(property "#{inspect($property)}" was requested): #{inspect($deprecated)}';
		}
		@if (type-of($deprecated) == 'map' and map-has-key($deprecated, $property)) {
			@warn 'The "#{inspect($property)}" property of "#{inspect($from)}" ' +
			'"#{inspect($usecase)}" color usecase is deprecated: ' +
			'#{inspect(map-get($deprecated, $property))}';
		}
		$_o-colors-deprecation-warnings-output: append($_o-colors-deprecation-warnings-output, $deprecated-key) !global;
	}

	@return oColorsByName($color);
}

/// Returns a customised version of our shade-able colors defined in
/// $_o-colors-tints
///
/// @param {String} $color-name - the name of the color to be shaded
/// @param {Number} $brightness - the brightness value of the new color
@function oColorsGetTint($color-name, $brightness) {
	$hue: null;
	$saturation: null;
	$mix: null;
	$newcolor: null;

	@if not (map-has-key($_o-colors-tints, $color-name)) {
		$color-tints: map-keys($_o-colors-tints);
		@return _error("It is not possible to use a tint of: #{$color-name}, please use one of: #{$color-tints} instead.");
	}

	@if (map-has-key(map-get($_o-colors-tints, $color-name), 'hue')) {
		$hue: map-get(map-get($_o-colors-tints, $color-name), 'hue');
		$saturation: map-get(map-get($_o-colors-tints, $color-name), 'saturation');
		$newcolor: _oColorsHSB($hue, $saturation, $brightness);
	} @else {
		$newcolor: oColorsMix($color-name, $percentage: $brightness);
	}

	@return $newcolor;
}

/// Returns a color based on the background context and base color
/// at the supplied percentage
///
/// @param {String|Color} $color [black] - palette name of color
/// @param {String|Color} $background [paper] - palette name of background color
/// @param {Number} $percentage [60] - percentage opacity of the foreground color over the background
@function oColorsMix($color: 'black', $background: oColorsByUsecase('page', 'background'), $percentage: 80) {
	$base: if(type-of($background) == 'string', oColorsByName($background), $background);
	$mixer: if(type-of($color) == 'string', oColorsByName($color), $color);

	@if type-of($base) != color {
		@return _error("'#{inspect($background)}' is not a valid base color.");
	}

	@if type-of($mixer) != color {
		@return _error("'#{inspect($color)}' is not a valid mixing color.");
	}

	@return mix($mixer, $base, $percentage);
}

/// Returns a text color based on the background and
/// an opacity percentage the color should appear at
///
/// @param {Color} $background - the palette name or hex of the background the text will appear on
/// @param {Number} $opacity [100] - the opacity percentage the text color should appear at
/// @param {String|Null} $minimum-contrast ['aa-normal'] - the minimum contrast ratio standard between the background and the returned text color, one of: aa-normal, aa-large, aaa-normal, aaa-large. See [WCAG 2.1 guidelines](https://www.w3.org/TR/WCAG21/#contrast-minimum). If the contrast ratio is too low to meet the selected guideline an error is thrown. Set to `null` to remove contrast checking and never throw an error.
@function oColorsGetTextColor($background, $opacity: 90, $minimum-contrast: 'aa-normal') {
	// Get background hex if palette colour name has been given.
	$background-name: $background;
	$background: if(type-of($background) == 'string', oColorsByName($background), $background);

	// Contrast values. See https://www.w3.org/TR/WCAG21/#contrast-minimum
	$contrast-levels: (
		'aa-normal': 4.5,
		'aa-large': 3,
		'aaa-normal': 7,
		'aaa-large': 4.5
	);

	// Validate arguments.
	@if($minimum-contrast != null and not map-has-key($contrast-levels, $minimum-contrast)) {
		@return _error('The minimum contrast must by one of "#{map-keys($contrast-levels)}" '+
		'or `null`. Found "#{inspect($minimum-contrast)}".');
	}

	@if type-of($background) != color {
		@return _error("'#{inspect($background)}' is not a valid color. To get a text color, please supply a valid hex code or color name for the background color'");
	}

	@if type-of($opacity) != 'number' {
		@return _error("'#{inspect($opacity)}' is not a valid opacity, set to a number.'");
	}

	// Calculate text colour for background and opacity.
	$required-contrast-ratio: map-get($contrast-levels, $minimum-contrast);
	$base-color: if(oColorsColorBrightness($background) > 35%, 'black', 'white');
	$text-color: oColorsMix($base-color, $background, $opacity);

	// Check text/background contrast ratio.
	$contrast-ratio: oColorsGetContrastRatio($text-color, $background);
	@if $minimum-contrast != null and $contrast-ratio < $required-contrast-ratio {
		@return _error(
			'The text colour generated for #{inspect($background-name)} at ' +
			'#{inspect($opacity)}% opacity has a contrast ratio of ' +
			'"#{inspect($contrast-ratio)}" and does not pass the WCAG 2.1 ' +
			'#{$minimum-contrast} required contrast ratio of at least ' +
			'#{$required-contrast-ratio}:1. Update the `$minimum-contrast` argument ' +
			'if a lower contrast is acceptable.'
		);
	}

	@return $text-color;
}

/// Work out the brightness value in % of a color
/// From: https://gist.github.com/jlong/f06f5843104ee10006fe
///
/// @param {Color} $color - color value to get brightness from (either a CSS colour or o-colors palette colour name)
@function oColorsColorBrightness($color) {
	$color: if(type-of($color) == 'string', oColorsByName($color), $color);

	$red-magic-number: 241;
	$green-magic-number: 691;
	$blue-magic-number: 68;

	$brightness-divisor: $red-magic-number + $green-magic-number + $blue-magic-number;

	// Extract color components
	$red-component: red($color);
	$green-component: green($color);
	$blue-component: blue($color);

	// Calculate a brightness value in 3d color space between 0 and 255
	$number: sqrt((($red-component * $red-component * $red-magic-number) + ($green-component * $green-component * $green-magic-number) + ($blue-component * $blue-component * $blue-magic-number)) / $brightness-divisor);

	// Convert to percentage and return
	@return 100% * ($number / 255);
}

/// Returns the luminance of `$color` as a float (between 0 and 1)
/// 1 is pure white, 0 is pure black.
/// From: https://css-tricks.com/snippets/sass/luminance-color-function/
/// @param {String|Color} $color -  The colour to return a luminance for (either a CSS colour or o-colors palette colour name)
/// @return {Number}
@function oColorsColorLuminance($color) {
	$color: if(type-of($color) == 'string', oColorsByName($color), $color);

	$colors: (
		'red': red($color),
		'green': green($color),
		'blue': blue($color)
	);

	@each $name, $value in $colors {
		$adjusted: 0;
		$value: $value / 255;

		@if $value < 0.03928 {
			$value: $value / 12.92;
		} @else {
			$value: ($value + 0.055) / 1.055;
			$value: pow($value, 2.4);
		}

		$colors: map-merge($colors, ($name: $value));
	}

	@return (map-get($colors, 'red') * 0.2126) + (map-get($colors, 'green') * 0.7152) + (map-get($colors, 'blue') * 0.0722);
}

/// Calculate the contrast ratio between two colours.
///
/// @param {String|Color} $color-a - first colour to compare (either a CSS colour or o-colors palette colour name)
/// @param {String|Color} $color-b - second colour to compare (either a CSS colour or o-colors palette colour name)
/// Based on the JS in https://github.com/LeaVerou/contrast-ratio/blob/gh-pages/contrast-ratio.js
@function oColorsGetContrastRatio($color-a, $color-b) {
	$l1: oColorsColorLuminance($color-a) + 0.05;
	$l2: oColorsColorLuminance($color-b) + 0.05;

	$ratio: $l1 / $l2;

	@if $l2 > $l1 {
		$ratio: 1 / $ratio;
	}

	$ratio: _oColorsPreciseFloor($ratio);

	@return $ratio;
}

/// Return color names and the component/project name they're from.
/// @return {List} - A list of maps with palette color details e.g. `(('name': 'paper', 'from': 'o-colors'), ('name': 'storm', 'from': 'o-example'))`
@function oColorsGetPalette() {
	$public-palette-details: ();

	@each $name, $color-map in $_o-colors-palette {
		$details: (
			'name': map-get($color-map, 'name'),
			'from': map-get($color-map, 'from')
		);
		$public-palette-details: append($public-palette-details, $details);
	}

	@return $public-palette-details;
}

/// Returns the web-safe HSLA color based on HSB/HSV values
///
/// @access private
///
/// @param {Number} $hue - number between 0-360
/// @param {Number} $saturation - number between 0-100
/// @param {Number} $brigthness - number between 0-100
/// @param {Number} $alpha [1] - number between 0-1
/// @access private
@function _oColorsHSB($hue, $saturation, $brightness, $alpha: 1) {
	@if $brightness == 0 {
		@return hsla(0, 0, 0, $alpha);
	} @else {
		$hsl-luminance: ($brightness/2) * (2 - ($saturation/100));
		$hsl-saturation: ($brightness * $saturation) / if($hsl-luminance < 50, $hsl-luminance * 2, 200 - $hsl-luminance * 2);

		@return hsla($hue, $hsl-saturation, $hsl-luminance, $alpha);
	}
}

/// @access private
@function _oColorsPreciseFloor($number, $decimals: 2) {
	$multiplier: pow(10, $decimals);
	@return floor($number * $multiplier) / $multiplier;
}

/// Allows for errors to be tested in dev environments
// Code from: https://github.com/oddbird/true/issues/92
/// @access private
@function _error($message, $capture: $_o-colors-test-environment) {
	@if $capture {
		@return 'ERROR: #{$message}';
	}

	@error('#{$message}');
};
