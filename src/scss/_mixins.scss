/// Define a new palette color.
///
/// @example scss - Add a custom palette color
///     @include oColorsSetColor($project-name: 'o-example', $color-name: 'pink', $color-hex: #ff69b4);
///
/// @example scss - Deprecate a set colour (removing a color from the palette is considered a breaking change and requires a major release).
///     @include oColorsSetColor(
///     	$project-name: 'o-example',
///     	$color-name: 'pink',
///     	$color-hex #ff69b4,
///     	$opts: (deprecated: 'your deprecation message')
///     );
///
/// @param {String} $project-name - The name of the component or project setting this colour, e.g. 'o-example'.
/// @param {String} $color-name - The name of the colour e.g. 'paper'.
/// @param {Color} $color-hex - The colour to set (hex) e.g. #ff69b4.
/// @param {Map} $opts - A map of options. Accepts a `deprecated` key with a message to deprecated a set colour e.g. `$opts: (deprecated: 'your deprecation message')`.
@mixin oColorsSetColor($project-name, $color-name, $color-hex, $opts: ()) {
	// Validate arguments are of correct type.
	$missing-namespace: type-of($project-name) != 'string';
	$missing-color-name: type-of($color-name) != 'string';
	$missing-color-hex: type-of($color-hex) != 'color';
	@if $missing-namespace or $missing-color-name {
		@error 'Expected a string `$project-name` and `$color-name` to set a new colour.';
	}
	@if $missing-color-hex {
		@error 'Expected `$color-hex ` to be a colour, found "#{$color-hex}" of type "#{type-of($color-hex)}".';
	}
	// Get the namespaced color name.
	$namespaced-color-name: '#{$project-name}-#{$color-name}';
	// Set the new colour to the colour palette.
	$deprecation-message: map-get($opts, 'deprecated');
	$new-color: ($namespaced-color-name: (
		'color': $color-hex,
		'name': $color-name,
		'from': $project-name,
		'meta': ('deprecated': $deprecation-message)
	));
	$_o-colors-palette: map-merge($_o-colors-palette, $new-color) !global;
};

/// Add a custom use case property
///
/// @example scss
///  @include oColorsSetUseCase(email, text, 'grey-tint5');
///
/// @param {String} $usecase - Name of the use case
/// @param {String} $property - Property it applies to
/// @param {String} $color - One of $_o-colors-palette
@mixin oColorsSetUseCase($usecase, $property, $color) {
	$namespaced-usecase: 'o-colors-#{$usecase}';
	$propmap: ($property: $color);

	// The use-case already exists,
	// combine its existing properties with the new one
	@if (map-has-key($o-colors-usecases, $namespaced-usecase)) {
		$propmap: map-merge(map-get($o-colors-usecases, $namespaced-usecase), $propmap);
	}

	$newmap: ($namespaced-usecase: $propmap);

	// Add the use-case and its properties to the global use-case map
	$o-colors-usecases: map-merge($o-colors-usecases, $newmap) !global;
}

/// Output property declarations for all defined properties for the specified use case
///
/// @example scss
///  .my-thing {
///  	@include oColorsFor(custom-box box);
///  }
///  .my-other-thing {
///  	@include oColorsFor(custom-box box, background border);
///  }
///
/// @param {String|list} $useCaseList
/// @param {String|list} $propertyList [all]
@mixin oColorsFor($useCaseList, $propertyList: all, $textLevel: 100) {
	// Fail silently when a use case doesn't exist,
	// taking advantage of how Sass treats the `null` keyword:
	//
	// 		$foo: null;
	// 		el { color: $foo; } // outputs nothing
	$args: (default: null);

	@if ($propertyList == 'all' or index($propertyList, 'background')) {
		background-color: oColorsGetColorFor($useCaseList, background, $options: $args);
	}

	@if ($propertyList == 'all' or index($propertyList, 'text')) {
		$useCaseTextColor: oColorsGetColorFor($useCaseList, text, $options: $args);
		$useCaseBackgroundColor: oColorsGetColorFor($useCaseList, background, $options: $args);

		// If no text color is defined but there is a background color for the use case
		@if $useCaseTextColor == null and $useCaseBackgroundColor != null {
			$useCaseTextColor: oColorsGetTextColor($useCaseBackgroundColor, $textLevel);
		}

		color: $useCaseTextColor;
	}

	@if ($propertyList == 'all' or index($propertyList, 'border')) {
		border-color: oColorsGetColorFor($useCaseList, border, $options: $args);
	}

	@if ($propertyList == 'all' or index($propertyList, 'outline')) {
		outline-color: oColorsGetColorFor($useCaseList, outline, $options: $args);
	}
}

/// Update the palette with calculated tints of
/// each color from $o-colors-tints
@mixin _oColorsSetPaletteTints {
	@each $color, $settings in $o-colors-tints {
		$hue: map-get($settings, 'hue');
		$tints: map-get($settings, 'tints');

		$saturation: null;
		$deprecated: null;

		@if map-has-key($settings, 'saturation') {
			$saturation: map-get($settings, 'saturation');
		}

		$deprecated:  map-has-key($settings, '_deprecated');

		@if $tints != null {
			@each $value in $tints {
				$name: "#{$color}-#{$value}";
				$tint: null;

				@if $saturation == null {
					$tint: oColorsMix($color, $percentage: $value);
				} @else {
					$tint: _oColorsHSB($hue, $saturation, $value);
				}

				// @todo use oColorsSetColor
				@include oColorsSetColor('o-colors', $name, $tint, $opts: (
					'deprecated': $deprecated
				));
			}
		}
	}
}

/// Update the palette with default o-colors palette colours.
@mixin _oColorsSetPaletteColors {
	@each $color-name, $color-details in $_o-colors-default-palette-colors {
		$color-hex: map-get($color-details, 'color');
		$opts: map-get($color-details, 'opts');
		@include oColorsSetColor('o-colors', $color-name, $color-hex, $opts);
	}
}

/// Output all palette colors as CSS Variables
@mixin _oColorsCSSVariables {
	:root {
		@each $color-map in oColorsGetPalette() {
			$name: map-get($color-map, 'name');
			#{--o-colors-}#{$name}: oColorsByName($name);
		}
	}
}
