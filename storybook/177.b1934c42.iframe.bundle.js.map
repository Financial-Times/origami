{"version":3,"file":"177.b1934c42.iframe.bundle.js","mappings":";;AAeA;AAEA;AACA;AAIA","sources":["webpack://origami-storybook/../../node_modules/@storybook/components/dist/modern/tooltip/WithTooltip.js"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { useCallback, useState, useEffect } from 'react';\nimport { styled } from '@storybook/theming';\nimport global from 'global';\nimport TooltipTrigger from 'react-popper-tooltip';\nimport { Tooltip } from './Tooltip';\nconst {\n  document\n} = global; // A target that doesn't speak popper\n\nconst TargetContainer = styled.div`\n  display: inline-block;\n  cursor: ${props => props.mode === 'hover' ? 'default' : 'pointer'};\n`;\nconst TargetSvgContainer = styled.g`\n  cursor: ${props => props.mode === 'hover' ? 'default' : 'pointer'};\n`;\n\n// Pure, does not bind to the body\nconst WithTooltipPure = (_ref) => {\n  let {\n    svg,\n    trigger,\n    placement,\n    modifiers,\n    hasChrome,\n    tooltip,\n    children,\n    tooltipShown,\n    onVisibilityChange\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"svg\", \"trigger\", \"closeOnClick\", \"placement\", \"modifiers\", \"hasChrome\", \"tooltip\", \"children\", \"tooltipShown\", \"onVisibilityChange\"]);\n\n  const Container = svg ? TargetSvgContainer : TargetContainer;\n  return /*#__PURE__*/React.createElement(TooltipTrigger, {\n    placement: placement,\n    trigger: trigger,\n    modifiers: modifiers,\n    tooltipShown: tooltipShown,\n    onVisibilityChange: onVisibilityChange,\n    tooltip: ({\n      getTooltipProps,\n      getArrowProps,\n      tooltipRef,\n      arrowRef,\n      placement: tooltipPlacement\n    }) => /*#__PURE__*/React.createElement(Tooltip, _extends({\n      hasChrome: hasChrome,\n      placement: tooltipPlacement,\n      tooltipRef: tooltipRef,\n      arrowRef: arrowRef,\n      arrowProps: getArrowProps()\n    }, getTooltipProps()), typeof tooltip === 'function' ? tooltip({\n      onHide: () => onVisibilityChange(false)\n    }) : tooltip)\n  }, ({\n    getTriggerProps,\n    triggerRef\n  }) =>\n  /*#__PURE__*/\n  // @ts-ignore\n  React.createElement(Container, _extends({\n    ref: triggerRef\n  }, getTriggerProps(), props), children));\n};\n\nWithTooltipPure.displayName = \"WithTooltipPure\";\nWithTooltipPure.defaultProps = {\n  svg: false,\n  trigger: 'hover',\n  closeOnClick: false,\n  placement: 'top',\n  modifiers: [{\n    name: 'preventOverflow',\n    options: {\n      padding: 8\n    }\n  }, {\n    name: 'offset',\n    options: {\n      offset: [8, 8]\n    }\n  }, {\n    name: 'arrow',\n    options: {\n      padding: 8\n    }\n  }],\n  hasChrome: true,\n  tooltipShown: false\n};\n\nconst WithToolTipState = (_ref2) => {\n  let {\n    startOpen,\n    onVisibilityChange: onChange\n  } = _ref2,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"startOpen\", \"onVisibilityChange\"]);\n\n  const [tooltipShown, setTooltipShown] = useState(startOpen || false);\n  const onVisibilityChange = useCallback(visibility => {\n    if (onChange && onChange(visibility) === false) return;\n    setTooltipShown(visibility);\n  }, [onChange]);\n  useEffect(() => {\n    const hide = () => onVisibilityChange(false);\n\n    document.addEventListener('keydown', hide, false); // Find all iframes on the screen and bind to clicks inside them (waiting until the iframe is ready)\n\n    const iframes = Array.from(document.getElementsByTagName('iframe'));\n    const unbinders = [];\n    iframes.forEach(iframe => {\n      const bind = () => {\n        try {\n          if (iframe.contentWindow.document) {\n            iframe.contentWindow.document.addEventListener('click', hide);\n            unbinders.push(() => {\n              try {\n                iframe.contentWindow.document.removeEventListener('click', hide);\n              } catch (e) {// logger.debug('Removing a click listener from iframe failed: ', e);\n              }\n            });\n          }\n        } catch (e) {// logger.debug('Adding a click listener to iframe failed: ', e);\n        }\n      };\n\n      bind(); // I don't know how to find out if it's already loaded so I potentially will bind twice\n\n      iframe.addEventListener('load', bind);\n      unbinders.push(() => {\n        iframe.removeEventListener('load', bind);\n      });\n    });\n    return () => {\n      document.removeEventListener('keydown', hide);\n      unbinders.forEach(unbind => {\n        unbind();\n      });\n    };\n  });\n  return /*#__PURE__*/React.createElement(WithTooltipPure, _extends({}, rest, {\n    tooltipShown: tooltipShown,\n    onVisibilityChange: onVisibilityChange\n  }));\n};\n\nWithToolTipState.displayName = \"WithToolTipState\";\nexport { WithTooltipPure, WithToolTipState, WithToolTipState as WithTooltip };"],"names":[],"sourceRoot":""}