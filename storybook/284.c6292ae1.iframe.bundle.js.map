{"version":3,"file":"284.c6292ae1.iframe.bundle.js","mappings":";;;;;AAiBA;ACKA;;AAEA;;AAIA;;AAUA;;;;AA4DA;;;;AAYA;;;;;;;;;;;;;;;;;;;;;ACjCA;;;;AClBA;AC8BA;;;AAIA;AAMA;;;AAIA;;;AC/FA;;;;;ACGA;;;ACKA;ACSA;;;AAIA;;;;ACuCA;ACFA;;;;AChBA;;AC1BA;;;;;;;ACVA;;;AA0BA;;;;;AAIA;;;;AACA","sources":["webpack://origami-storybook/./node_modules/@storybook/theming/dist/modern/ensure.js","webpack://origami-storybook/./node_modules/@storybook/client-api/dist/modern/ClientApi.js","webpack://origami-storybook/./node_modules/@storybook/components/dist/modern/controls/options/Select.js","webpack://origami-storybook/./node_modules/@storybook/components/dist/modern/controls/options/Options.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/args.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/GlobalsStore.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/normalizeStory.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/prepareStory.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/inferArgTypes.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/parseArgsParam.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/WebView.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/PreviewWeb.js","webpack://origami-storybook/./node_modules/@storybook/channels/dist/modern/index.js","webpack://origami-storybook/./node_modules/@storybook/theming/dist/modern/animation.js"],"sourcesContent":["import { logger } from '@storybook/client-logger';\nimport { deletedDiff } from 'deep-object-diff';\nimport dedent from 'ts-dedent';\nimport light from './themes/light';\nimport { convert } from './convert';\nexport const ensure = input => {\n  if (!input) {\n    return convert(light);\n  }\n\n  const missing = deletedDiff(light, input);\n\n  if (Object.keys(missing).length) {\n    logger.warn(dedent`\n          Your theme is missing properties, you should update your theme!\n\n          theme-data missing:\n        `, missing);\n  }\n\n  return convert(input);\n};","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport { toId, sanitize } from '@storybook/csf';\nimport { combineParameters, normalizeInputTypes } from '@storybook/store';\nimport { StoryStoreFacade } from './StoryStoreFacade';\nconst {\n  FEATURES\n} = global;\n// ClientApi (and StoreStore) are really singletons. However they are not created until the\n// relevant framework instanciates them via `start.js`. The good news is this happens right away.\nlet singleton;\nconst warningAlternatives = {\n  addDecorator: `Instead, use \\`export const decorators = [];\\` in your \\`preview.js\\`.`,\n  addParameters: `Instead, use \\`export const parameters = {};\\` in your \\`preview.js\\`.`,\n  addLoaders: `Instead, use \\`export const loaders = [];\\` in your \\`preview.js\\`.`\n};\n\nconst warningMessage = method => deprecate(() => {}, dedent`\n  \\`${method}\\` is deprecated, and will be removed in Storybook 7.0.\n\n  ${warningAlternatives[method]}\n\n  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`);\n\nconst warnings = {\n  addDecorator: warningMessage('addDecorator'),\n  addParameters: warningMessage('addParameters'),\n  addLoaders: warningMessage('addLoaders')\n};\n\nconst checkMethod = (method, deprecationWarning) => {\n  if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n    throw new Error(dedent`You cannot use \\`${method}\\` with the new Story Store.\n      \n      ${warningAlternatives[method]}`);\n  }\n\n  if (!singleton) {\n    throw new Error(`Singleton client API not yet initialized, cannot call \\`${method}\\`.`);\n  }\n\n  if (deprecationWarning) {\n    warnings[method]();\n  }\n};\n\nexport const addDecorator = (decorator, deprecationWarning = true) => {\n  checkMethod('addDecorator', deprecationWarning);\n  singleton.addDecorator(decorator);\n};\nexport const addParameters = (parameters, deprecationWarning = true) => {\n  checkMethod('addParameters', deprecationWarning);\n  singleton.addParameters(parameters);\n};\nexport const addLoader = (loader, deprecationWarning = true) => {\n  checkMethod('addLoader', deprecationWarning);\n  singleton.addLoader(loader);\n};\nexport const addArgsEnhancer = enhancer => {\n  checkMethod('addArgsEnhancer', false);\n  singleton.addArgsEnhancer(enhancer);\n};\nexport const addArgTypesEnhancer = enhancer => {\n  checkMethod('addArgTypesEnhancer', false);\n  singleton.addArgTypesEnhancer(enhancer);\n};\nexport const getGlobalRender = () => {\n  checkMethod('getGlobalRender', false);\n  return singleton.facade.projectAnnotations.render;\n};\nexport const setGlobalRender = render => {\n  checkMethod('setGlobalRender', false);\n  singleton.facade.projectAnnotations.render = render;\n};\nconst invalidStoryTypes = new Set(['string', 'number', 'boolean', 'symbol']);\nexport class ClientApi {\n  // If we don't get passed modules so don't know filenames, we can\n  // just use numeric indexes\n  constructor({\n    storyStore\n  } = {}) {\n    this.facade = void 0;\n    this.storyStore = void 0;\n    this.addons = void 0;\n    this.onImportFnChanged = void 0;\n    this.lastFileName = 0;\n    this.setAddon = deprecate(addon => {\n      this.addons = Object.assign({}, this.addons, addon);\n    }, dedent`\n      \\`setAddon\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon\n    `);\n\n    this.addDecorator = decorator => {\n      this.facade.projectAnnotations.decorators.push(decorator);\n    };\n\n    this.clearDecorators = deprecate(() => {\n      this.facade.projectAnnotations.decorators = [];\n    }, dedent`\n      \\`clearDecorators\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators\n    `);\n\n    this.addParameters = (_ref) => {\n      let {\n        globals,\n        globalTypes\n      } = _ref,\n          parameters = _objectWithoutPropertiesLoose(_ref, [\"globals\", \"globalTypes\"]);\n\n      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters);\n\n      if (globals) {\n        this.facade.projectAnnotations.globals = Object.assign({}, this.facade.projectAnnotations.globals, globals);\n      }\n\n      if (globalTypes) {\n        this.facade.projectAnnotations.globalTypes = Object.assign({}, this.facade.projectAnnotations.globalTypes, normalizeInputTypes(globalTypes));\n      }\n    };\n\n    this.addLoader = loader => {\n      this.facade.projectAnnotations.loaders.push(loader);\n    };\n\n    this.addArgsEnhancer = enhancer => {\n      this.facade.projectAnnotations.argsEnhancers.push(enhancer);\n    };\n\n    this.addArgTypesEnhancer = enhancer => {\n      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);\n    };\n\n    this.storiesOf = (kind, m) => {\n      if (!kind && typeof kind !== 'string') {\n        throw new Error('Invalid or missing kind provided for stories, should be a string');\n      }\n\n      if (!m) {\n        logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`);\n      }\n\n      if (m) {\n        const proto = Object.getPrototypeOf(m);\n\n        if (proto.exports && proto.exports.default) {\n          // FIXME: throw an error in SB6.0\n          logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);\n        }\n      } // eslint-disable-next-line no-plusplus\n\n\n      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();\n      let fileName = baseFilename;\n      let i = 1; // Deal with `storiesOf()` being called twice in the same file.\n      // On HMR, `this.csfExports[fileName]` will be reset to `{}`, so an empty object is due\n      // to this export, not a second call of `storiesOf()`.\n\n      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {\n        i += 1;\n        fileName = `${baseFilename}-${i}`;\n      }\n\n      if (m && m.hot && m.hot.accept) {\n        // This module used storiesOf(), so when it re-runs on HMR, it will reload\n        // itself automatically without us needing to look at our imports\n        m.hot.accept();\n        m.hot.dispose(() => {\n          this.facade.clearFilenameExports(fileName); // We need to update the importFn as soon as the module re-evaluates\n          // (and calls storiesOf() again, etc). We could call `onImportFnChanged()`\n          // at the end of every setStories call (somehow), but then we'd need to\n          // debounce it somehow for initial startup. Instead, we'll take advantage of\n          // the fact that the evaluation of the module happens immediately in the same tick\n\n          setTimeout(() => {\n            var _this$onImportFnChang;\n\n            (_this$onImportFnChang = this.onImportFnChanged) === null || _this$onImportFnChang === void 0 ? void 0 : _this$onImportFnChang.call(this, {\n              importFn: this.importFn.bind(this)\n            });\n          }, 0);\n        });\n      }\n\n      let hasAdded = false;\n      const api = {\n        kind: kind.toString(),\n        add: () => api,\n        addDecorator: () => api,\n        addLoader: () => api,\n        addParameters: () => api\n      }; // apply addons\n\n      Object.keys(this.addons).forEach(name => {\n        const addon = this.addons[name];\n\n        api[name] = (...args) => {\n          addon.apply(api, args);\n          return api;\n        };\n      });\n      const meta = {\n        id: sanitize(kind),\n        title: kind,\n        decorators: [],\n        loaders: [],\n        parameters: {}\n      }; // We map these back to a simple default export, even though we have type guarantees at this point\n\n      this.facade.csfExports[fileName] = {\n        default: meta\n      };\n\n      api.add = (storyName, storyFn, parameters = {}) => {\n        hasAdded = true;\n\n        if (typeof storyName !== 'string') {\n          throw new Error(`Invalid or missing storyName provided for a \"${kind}\" story.`);\n        }\n\n        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {\n          throw new Error(`Cannot load story \"${storyName}\" in \"${kind}\" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);\n        }\n\n        const {\n          decorators,\n          loaders\n        } = parameters,\n              storyParameters = _objectWithoutPropertiesLoose(parameters, [\"decorators\", \"loaders\"]);\n\n        const csfExports = this.facade.csfExports[fileName]; // Whack a _ on the front incase it is \"default\"\n\n        csfExports[`_${sanitize(storyName)}`] = {\n          name: storyName,\n          parameters: Object.assign({\n            fileName\n          }, storyParameters),\n          decorators,\n          loaders,\n          render: storyFn\n        }; // eslint-disable-next-line no-underscore-dangle\n\n        const storyId = parameters.__id || toId(kind, storyName);\n        this.facade.stories[storyId] = {\n          id: storyId,\n          title: csfExports.default.title,\n          name: storyName,\n          importPath: fileName\n        };\n        return api;\n      };\n\n      api.addDecorator = decorator => {\n        if (hasAdded) throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.decorators.push(decorator);\n        return api;\n      };\n\n      api.addLoader = loader => {\n        if (hasAdded) throw new Error(`You cannot add a loader after the first story for a kind.`);\n        meta.loaders.push(loader);\n        return api;\n      };\n\n      api.addParameters = parameters => {\n        if (hasAdded) throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.parameters = combineParameters(meta.parameters, parameters);\n        return api;\n      };\n\n      return api;\n    };\n\n    this.getStorybook = () => {\n      const {\n        stories\n      } = this.storyStore.storyIndex;\n      const kinds = {};\n      Object.entries(stories).forEach(([storyId, {\n        title,\n        name,\n        importPath\n      }]) => {\n        if (!kinds[title]) {\n          kinds[title] = {\n            kind: title,\n            fileName: importPath,\n            stories: []\n          };\n        }\n\n        const {\n          storyFn\n        } = this.storyStore.fromId(storyId);\n        kinds[title].stories.push({\n          name,\n          render: storyFn\n        });\n      });\n      return Object.values(kinds);\n    };\n\n    this.raw = () => {\n      return this.storyStore.raw();\n    };\n\n    this.facade = new StoryStoreFacade();\n    this.addons = {};\n    this.storyStore = storyStore;\n    singleton = this;\n  }\n\n  importFn(path) {\n    return this.facade.importFn(path);\n  }\n\n  getStoryIndex() {\n    if (!this.storyStore) {\n      throw new Error('Cannot get story index before setting storyStore');\n    }\n\n    return this.facade.getStoryIndex(this.storyStore);\n  }\n\n  // @deprecated\n  get _storyStore() {\n    return this.storyStore;\n  }\n\n}","import React from 'react';\nimport { styled } from '@storybook/theming';\nimport { logger } from '@storybook/client-logger';\nimport { selectedKey, selectedKeys, selectedValues } from './helpers';\nimport { Icons } from '../../icon/icon';\nimport { getControlId } from '../helpers';\nconst styleResets = {\n  // resets\n  appearance: 'none',\n  border: '0 none',\n  boxSizing: 'inherit',\n  display: ' block',\n  margin: ' 0',\n  background: 'transparent',\n  padding: 0,\n  fontSize: 'inherit',\n  position: 'relative'\n};\nconst OptionsSelect = styled.select(({\n  theme\n}) => Object.assign({}, styleResets, {\n  boxSizing: 'border-box',\n  position: 'relative',\n  padding: '6px 10px',\n  width: '100%',\n  color: theme.input.color || 'inherit',\n  background: theme.input.background,\n  borderRadius: theme.input.borderRadius,\n  boxShadow: `${theme.input.border} 0 0 0 1px inset`,\n  fontSize: theme.typography.size.s2 - 1,\n  lineHeight: '20px',\n  '&:focus': {\n    boxShadow: `${theme.color.secondary} 0 0 0 1px inset`,\n    outline: 'none'\n  },\n  '&[disabled]': {\n    cursor: 'not-allowed',\n    opacity: 0.5\n  },\n  '::placeholder': {\n    color: theme.color.mediumdark\n  },\n  '&[multiple]': {\n    overflow: 'auto',\n    padding: 0,\n    option: {\n      display: 'block',\n      padding: '6px 10px',\n      marginLeft: 1,\n      marginRight: 1\n    }\n  }\n}));\nconst SelectWrapper = styled.span`\n  display: inline-block;\n  line-height: normal;\n  overflow: hidden;\n  position: relative;\n  vertical-align: top;\n  width: 100%;\n\n  svg {\n    position: absolute;\n    z-index: 1;\n    pointer-events: none;\n    height: 12px;\n    margin-top: -6px;\n    right: 12px;\n    top: 50%;\n\n    path {\n      fill: currentColor;\n    }\n  }\n`;\nconst NO_SELECTION = 'Choose option...';\n\nconst SingleSelect = ({\n  name,\n  value,\n  options,\n  onChange\n}) => {\n  const handleChange = e => {\n    onChange(options[e.currentTarget.value]);\n  };\n\n  const selection = selectedKey(value, options) || NO_SELECTION;\n  const controlId = getControlId(name);\n  return /*#__PURE__*/React.createElement(SelectWrapper, null, /*#__PURE__*/React.createElement(Icons, {\n    icon: \"arrowdown\"\n  }), /*#__PURE__*/React.createElement(OptionsSelect, {\n    id: controlId,\n    value: selection,\n    onChange: handleChange\n  }, /*#__PURE__*/React.createElement(\"option\", {\n    key: \"no-selection\",\n    disabled: true\n  }, NO_SELECTION), Object.keys(options).map(key => /*#__PURE__*/React.createElement(\"option\", {\n    key: key\n  }, key))));\n};\n\nSingleSelect.displayName = \"SingleSelect\";\n\nconst MultiSelect = ({\n  name,\n  value,\n  options,\n  onChange\n}) => {\n  const handleChange = e => {\n    const selection = Array.from(e.currentTarget.options).filter(option => option.selected).map(option => option.value);\n    onChange(selectedValues(selection, options));\n  };\n\n  const selection = selectedKeys(value, options);\n  const controlId = getControlId(name);\n  return /*#__PURE__*/React.createElement(SelectWrapper, null, /*#__PURE__*/React.createElement(OptionsSelect, {\n    id: controlId,\n    multiple: true,\n    value: selection,\n    onChange: handleChange\n  }, Object.keys(options).map(key => /*#__PURE__*/React.createElement(\"option\", {\n    key: key\n  }, key))));\n};\n\nMultiSelect.displayName = \"MultiSelect\";\nexport const SelectControl = props => {\n  const {\n    name,\n    options\n  } = props;\n\n  if (!options) {\n    logger.warn(`Select with no options: ${name}`);\n    return /*#__PURE__*/React.createElement(React.Fragment, null, \"-\");\n  } // eslint-disable-next-line react/destructuring-assignment\n\n\n  return props.isMulti ? /*#__PURE__*/React.createElement(MultiSelect, props) : /*#__PURE__*/React.createElement(SingleSelect, props);\n};","import \"core-js/modules/es.array.reduce.js\";\nimport React from 'react';\nimport dedent from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport { CheckboxControl } from './Checkbox';\nimport { RadioControl } from './Radio';\nimport { SelectControl } from './Select';\n\n/**\n * Options can accept `options` in two formats:\n * - array: ['a', 'b', 'c'] OR\n * - object: { a: 1, b: 2, c: 3 } (deprecated)\n *\n * We always normalize to the more generalized object format and ONLY handle\n * the object format in the underlying control implementations.\n *\n * While non-primitive values are deprecated, they might still not be valid\n * object keys, so the resulting object is a Label -> Value mapping.\n */\nconst normalizeOptions = (options, labels) => {\n  if (Array.isArray(options)) {\n    return options.reduce((acc, item) => {\n      acc[(labels === null || labels === void 0 ? void 0 : labels[item]) || String(item)] = item;\n      return acc;\n    }, {});\n  }\n\n  return options;\n};\n\nconst Controls = {\n  check: CheckboxControl,\n  'inline-check': CheckboxControl,\n  radio: RadioControl,\n  'inline-radio': RadioControl,\n  select: SelectControl,\n  'multi-select': SelectControl\n};\nexport const OptionsControl = props => {\n  const {\n    type = 'select',\n    options,\n    labels,\n    argType\n  } = props;\n  const normalized = Object.assign({}, props, {\n    options: normalizeOptions(options || argType.options, labels),\n    isInline: type.includes('inline'),\n    isMulti: type.includes('multi')\n  });\n\n  if (options) {\n    once.warn(dedent`\n      'control.options' is deprecated and will be removed in Storybook 7.0. Define 'options' directly on the argType instead, and use 'control.labels' for custom labels.\n\n      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-controloptions\n    `);\n  }\n\n  const Control = Controls[type];\n\n  if (Control) {\n    return /*#__PURE__*/React.createElement(Control, normalized);\n  }\n\n  throw new Error(`Unknown options type: ${type}`);\n};","import \"core-js/modules/es.array.reduce.js\";\nimport deepEqual from 'fast-deep-equal';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject';\nimport dedent from 'ts-dedent';\nconst INCOMPATIBLE = Symbol('incompatible');\n\nconst map = (arg, type) => {\n  if (arg === undefined || arg === null || !type) return arg;\n\n  switch (type.name) {\n    case 'string':\n      return String(arg);\n\n    case 'enum':\n      return arg;\n\n    case 'number':\n      return Number(arg);\n\n    case 'boolean':\n      return arg === 'true';\n\n    case 'array':\n      if (!type.value || !Array.isArray(arg)) return INCOMPATIBLE;\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, type.value);\n        if (mapped !== INCOMPATIBLE) acc[index] = mapped;\n        return acc;\n      }, new Array(arg.length));\n\n    case 'object':\n      if (typeof arg === 'string' || typeof arg === 'number') return arg;\n      if (!type.value || typeof arg !== 'object') return INCOMPATIBLE;\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, type.value[key]);\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n          [key]: mapped\n        });\n      }, {});\n\n    default:\n      return INCOMPATIBLE;\n  }\n};\n\nexport const mapArgsToTypes = (args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) return acc;\n    const mapped = map(value, argTypes[key].type);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n      [key]: mapped\n    });\n  }, {});\n};\nexport const combineArgs = (value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce((acc, upd, index) => {\n      acc[index] = combineArgs(value[index], update[index]);\n      return acc;\n    }, [...value]).filter(v => v !== undefined);\n  }\n\n  if (!isPlainObject(value) || !isPlainObject(update)) return update;\n  return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== undefined) acc[key] = combined;\n    } else {\n      acc[key] = value[key];\n    }\n\n    return acc;\n  }, {});\n};\nexport const validateOptions = (args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, {\n    options\n  }]) => {\n    if (!options) {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n\n      return acc;\n    }\n\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    if (options.some(opt => opt && ['object', 'function'].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex(val => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n\n    if (args[key] === undefined || options.includes(args[key]) || isValidArray) {\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map(opt => typeof opt === 'string' ? `'${opt}'` : String(opt)).join(', ');\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}; // TODO -- copied from router, needs to be in a shared location\n\nexport const DEEPLY_EQUAL = Symbol('Deeply equal');\nexport const deepDiff = (value, update) => {\n  if (typeof value !== typeof update) return update;\n  if (deepEqual(value, update)) return DEEPLY_EQUAL;\n\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) acc[index] = diff;\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) return res;\n    return res.concat(new Array(value.length - update.length).fill(undefined));\n  }\n\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n      const diff = deepDiff(value === null || value === void 0 ? void 0 : value[key], update === null || update === void 0 ? void 0 : update[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, {\n        [key]: diff\n      });\n    }, {});\n  }\n\n  return update;\n};","import \"core-js/modules/es.array.reduce.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport { deepDiff, DEEPLY_EQUAL } from './args';\nconst setUndeclaredWarning = deprecate(() => {}, dedent`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `);\nexport class GlobalsStore {\n  constructor() {\n    this.allowedGlobalNames = void 0;\n    this.initialGlobals = void 0;\n    this.globals = {};\n  }\n\n  // NOTE: globals are initialized every time the preview entries are loaded\n  // This happens both initially when the SB first loads, and also on HMR\n  initialize({\n    globals,\n    globalTypes\n  }) {\n    this.setInitialGlobals({\n      globals,\n      globalTypes\n    });\n    this.globals = this.initialGlobals;\n  }\n\n  setInitialGlobals({\n    globals = {},\n    globalTypes = {}\n  }) {\n    this.allowedGlobalNames = new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = Object.entries(globalTypes).reduce((acc, [key, {\n      defaultValue\n    }]) => {\n      if (defaultValue) acc[key] = defaultValue;\n      return acc;\n    }, {});\n    this.initialGlobals = Object.assign({}, defaultGlobals, globals);\n  }\n\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted); // Note that unlike args, we do not have the same type information for globals to allow us\n    // to type check them here, so we just set them naively\n\n    this.globals = Object.assign({}, this.globals, allowedUrlGlobals);\n  }\n\n  resetOnProjectAnnotationsChange({\n    globals,\n    globalTypes\n  }) {\n    const delta = deepDiff(this.initialGlobals, this.globals);\n    this.setInitialGlobals({\n      globals,\n      globalTypes\n    });\n    this.globals = this.initialGlobals;\n\n    if (delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n\n  get() {\n    return this.globals;\n  }\n\n  update(newGlobals) {\n    Object.keys(newGlobals).forEach(key => {\n      if (!this.allowedGlobalNames.has(key)) {\n        setUndeclaredWarning();\n      }\n    });\n    this.globals = Object.assign({}, this.globals, newGlobals);\n  }\n\n}","import { storyNameFromExport, toId } from '@storybook/csf';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nimport { normalizeInputTypes } from './normalizeInputTypes';\nconst deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nconst deprecatedStoryAnnotationWarning = deprecate(() => {}, deprecatedStoryAnnotation);\nexport function normalizeStory(key, storyAnnotations, meta) {\n  let userStoryFn;\n  let storyObject;\n\n  if (typeof storyAnnotations === 'function') {\n    userStoryFn = storyAnnotations;\n    storyObject = storyAnnotations;\n  } else {\n    storyObject = storyAnnotations;\n  }\n\n  const {\n    story\n  } = storyObject;\n\n  if (story) {\n    logger.debug('deprecated story', story);\n    deprecatedStoryAnnotationWarning();\n  }\n\n  const exportName = storyNameFromExport(key);\n  const id = toId(meta.id || meta.title, exportName);\n  const name = typeof storyObject !== 'function' && storyObject.name || storyObject.storyName || (story === null || story === void 0 ? void 0 : story.name) || exportName;\n  const decorators = storyObject.decorators || (story === null || story === void 0 ? void 0 : story.decorators);\n  const parameters = storyObject.parameters || (story === null || story === void 0 ? void 0 : story.parameters);\n  const args = storyObject.args || (story === null || story === void 0 ? void 0 : story.args);\n  const argTypes = storyObject.argTypes || (story === null || story === void 0 ? void 0 : story.argTypes);\n  const loaders = storyObject.loaders || (story === null || story === void 0 ? void 0 : story.loaders);\n  const {\n    render,\n    play\n  } = storyObject;\n  return Object.assign({\n    id,\n    name\n  }, decorators && {\n    decorators\n  }, parameters && {\n    parameters\n  }, args && {\n    args\n  }, argTypes && {\n    argTypes: normalizeInputTypes(argTypes)\n  }, loaders && {\n    loaders\n  }, render && {\n    render\n  }, userStoryFn && {\n    userStoryFn\n  }, play && {\n    play\n  });\n}","import \"core-js/modules/es.array.reduce.js\";\nimport dedent from 'ts-dedent';\nimport deprecate from 'util-deprecate';\nimport global from 'global';\nimport { combineParameters } from './parameters';\nimport { applyHooks } from './hooks';\nimport { defaultDecorateStory } from './decorators';\nconst argTypeDefaultValueWarning = deprecate(() => {}, dedent`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-argtype-defaultValue`); // Combine all the metadata about a story (both direct and inherited from the component/global scope)\n// into a \"renderable\" story function, with all decorators applied, parameters passed as context etc\n//\n// Note that this story function is *stateless* in the sense that it does not track args or globals\n// Instead, it is expected these are tracked separately (if necessary) and are passed into each invocation.\n\nexport function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  var _global$FEATURES;\n\n  // NOTE: in the current implementation we are doing everything once, up front, rather than doing\n  // anything at render time. The assumption is that as we don't load all the stories at once, this\n  // will have a limited cost. If this proves misguided, we can refactor it.\n  const {\n    id,\n    name\n  } = storyAnnotations;\n  const {\n    title\n  } = componentAnnotations;\n  const parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations.parameters);\n  const decorators = [...(storyAnnotations.decorators || []), ...(componentAnnotations.decorators || []), ...(projectAnnotations.decorators || [])]; // Currently it is only possible to set these globally\n\n  const {\n    applyDecorators = defaultDecorateStory,\n    argTypesEnhancers = [],\n    argsEnhancers = []\n  } = projectAnnotations;\n  const loaders = [...(projectAnnotations.loaders || []), ...(componentAnnotations.loaders || []), ...(storyAnnotations.loaders || [])]; // The render function on annotations *has* to be an `ArgsStoryFn`, so when we normalize\n  // CSFv1/2, we use a new field called `userStoryFn` so we know that it can be a LegacyStoryFn\n\n  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;\n  const passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations.argTypes);\n  const {\n    passArgsFirst = true\n  } = parameters; // eslint-disable-next-line no-underscore-dangle\n\n  parameters.__isArgsStory = passArgsFirst && render.length > 0; // Pull out args[X] into initialArgs for argTypes enhancers\n\n  const passedArgs = combineParameters(projectAnnotations.args, componentAnnotations.args, storyAnnotations.args);\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title,\n    kind: title,\n    // Back compat\n    id,\n    name,\n    story: name,\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer(Object.assign({}, contextForEnhancers, {\n    argTypes: accumulatedArgTypes\n  })), contextForEnhancers.argTypes); // Add argTypes[X].defaultValue to initial args (note this deprecated)\n  // We need to do this *after* the argTypesEnhancers as they may add defaultValues\n\n  const defaultArgs = Object.entries(contextForEnhancers.argTypes).reduce((acc, [arg, {\n    defaultValue\n  }]) => {\n    if (typeof defaultValue !== 'undefined') {\n      acc[arg] = defaultValue;\n    }\n\n    return acc;\n  }, {});\n\n  if (Object.keys(defaultArgs).length > 0) {\n    argTypeDefaultValueWarning();\n  }\n\n  const initialArgsBeforeEnhancers = Object.assign({}, defaultArgs, passedArgs);\n  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => Object.assign({}, accumulatedArgs, enhancer(Object.assign({}, contextForEnhancers, {\n    initialArgs: initialArgsBeforeEnhancers\n  }))), initialArgsBeforeEnhancers); // Add some of our metadata into parameters as we used to do this in 6.x and users may be relying on it\n\n  if (!((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.breakingChangesV7)) {\n    contextForEnhancers.parameters = Object.assign({}, contextForEnhancers.parameters, {\n      __id: id,\n      globals: projectAnnotations.globals,\n      globalTypes: projectAnnotations.globalTypes,\n      args: contextForEnhancers.initialArgs,\n      argTypes: contextForEnhancers.argTypes\n    });\n  }\n\n  const applyLoaders = async context => {\n    const loadResults = await Promise.all(loaders.map(loader => loader(context)));\n    const loaded = Object.assign({}, ...loadResults);\n    return Object.assign({}, context, {\n      loaded\n    });\n  };\n\n  const undecoratedStoryFn = context => {\n    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {\n      var _context$argTypes$key;\n\n      const mapping = (_context$argTypes$key = context.argTypes[key]) === null || _context$argTypes$key === void 0 ? void 0 : _context$argTypes$key.mapping;\n      acc[key] = mapping && val in mapping ? mapping[val] : val;\n      return acc;\n    }, {});\n    const mappedContext = Object.assign({}, context, {\n      args: mappedArgs\n    });\n    const {\n      passArgsFirst: renderTimePassArgsFirst = true\n    } = context.parameters;\n    return renderTimePassArgsFirst ? render(mappedArgs, mappedContext) : render(mappedContext);\n  };\n\n  const unboundStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n  const {\n    play\n  } = storyAnnotations;\n\n  const runPlayFunction = async () => {\n    if (play) {\n      return play();\n    }\n\n    return undefined;\n  };\n\n  return Object.freeze(Object.assign({}, contextForEnhancers, {\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    runPlayFunction\n  }));\n}","import mapValues from 'lodash/mapValues';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport { combineParameters } from './parameters';\n\nconst inferType = (value, name, visited) => {\n  const type = typeof value;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'function':\n    case 'symbol':\n      return {\n        name: type\n      };\n\n    default:\n      break;\n  }\n\n  if (value) {\n    if (visited.has(value)) {\n      logger.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        More info: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `);\n      return {\n        name: 'other',\n        value: 'cyclic object'\n      };\n    }\n\n    visited.add(value);\n\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : {\n        name: 'other',\n        value: 'unknown'\n      };\n      return {\n        name: 'array',\n        value: childType\n      };\n    }\n\n    const fieldTypes = mapValues(value, field => inferType(field, name, new Set(visited)));\n    return {\n      name: 'object',\n      value: fieldTypes\n    };\n  }\n\n  return {\n    name: 'object',\n    value: {}\n  };\n};\n\nexport const inferArgTypes = context => {\n  const {\n    id,\n    argTypes: userArgTypes = {},\n    initialArgs = {}\n  } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = true;","import \"core-js/modules/es.array.reduce.js\";\nimport qs from 'qs';\nimport dedent from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport dedent from 'ts-dedent';\nconst {\n  document\n} = global;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nconst classes = {\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n  }\n\n  // Get ready to render a story, returning the element to render to\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('docs-root');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(message);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(stack);\n    document.body.classList.remove(classes.MAIN);\n    document.body.classList.remove(classes.NOPREVIEW);\n    document.body.classList.add(classes.ERROR);\n  }\n\n  showNoPreview() {\n    var _this$storyRoot, _this$docsRoot;\n\n    document.body.classList.remove(classes.MAIN);\n    document.body.classList.remove(classes.ERROR);\n    document.body.classList.add(classes.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    (_this$storyRoot = this.storyRoot()) === null || _this$storyRoot === void 0 ? void 0 : _this$storyRoot.setAttribute('hidden', 'true');\n    (_this$docsRoot = this.docsRoot()) === null || _this$docsRoot === void 0 ? void 0 : _this$docsRoot.setAttribute('hidden', 'true');\n  }\n\n  showMain() {\n    document.body.classList.remove(classes.NOPREVIEW);\n    document.body.classList.remove(classes.ERROR);\n    document.body.classList.add(classes.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n}","import \"core-js/modules/es.array.reduce.js\";\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport Events from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport global from 'global';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nimport { NoDocs } from './NoDocs';\nimport { StoryIndexClient } from './StoryIndexClient';\nconst {\n  window: globalWindow,\n  AbortController,\n  FEATURES\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nconst INVALIDATE = 'INVALIDATE';\nexport class PreviewWeb {\n  constructor() {\n    this.channel = void 0;\n    this.urlStore = void 0;\n    this.indexClient = void 0;\n    this.storyStore = void 0;\n    this.view = void 0;\n    this.renderToDOM = void 0;\n    this.previousSelection = void 0;\n    this.previousStory = void 0;\n    this.previousCleanup = void 0;\n    this.channel = addons.getChannel();\n    this.view = new WebView();\n    this.urlStore = new UrlStore();\n    this.storyStore = new StoryStore(); // Add deprecated APIs for back-compat\n    // @ts-ignore\n\n    this.storyStore.getSelection = deprecate(() => this.urlStore.selection, dedent`\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      `);\n  }\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    const projectAnnotations = this.getProjectAnnotationsOrRenderError(getProjectAnnotations) || {};\n\n    if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n      this.indexClient = new StoryIndexClient();\n      return this.indexClient.fetch().then(fetchedStoryIndex => {\n        this.storyStore.initialize({\n          getStoryIndex: () => fetchedStoryIndex,\n          importFn,\n          projectAnnotations,\n          cache: false\n        });\n        return this.setupListenersAndRenderSelection();\n      });\n    }\n\n    if (!getStoryIndex) {\n      throw new Error('No `getStoryIndex` passed defined in v6 mode');\n    }\n\n    this.storyStore.initialize({\n      getStoryIndex,\n      importFn,\n      projectAnnotations,\n      cache: true\n    });\n    return this.setupListenersAndRenderSelection();\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    let projectAnnotations;\n\n    try {\n      projectAnnotations = getProjectAnnotations();\n      this.renderToDOM = projectAnnotations.renderToDOM;\n      return projectAnnotations;\n    } catch (err) {\n      logger.warn(err); // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n\n      this.renderPreviewEntryError(err);\n      return undefined;\n    }\n  }\n\n  async setupListenersAndRenderSelection() {\n    this.setupListeners();\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.channel.emit(Events.SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n    await this.selectSpecifiedStory();\n\n    if (!(FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7)) {\n      this.channel.emit(Events.SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n  }\n\n  setupListeners() {\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    if (this.indexClient) this.indexClient.addEventListener(INVALIDATE, this.onStoryIndexChanged.bind(this));\n    this.channel.on(Events.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(Events.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(Events.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(Events.RESET_STORY_ARGS, this.onResetArgs.bind(this));\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.urlStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      viewMode,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const storyId = this.storyStore.storyIndex.storyIdFromSpecifier(storySpecifier);\n\n    if (!storyId) {\n      this.renderMissingStory(storySpecifier);\n      return;\n    }\n\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(Events.STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  }\n\n  onKeydown(event) {\n    if (!focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(Events.PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  onSetCurrentStory(selection) {\n    this.urlStore.setSelection(selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateGlobals({\n    globals\n  }) {\n    this.storyStore.globals.update(globals);\n    this.channel.emit(Events.GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    this.channel.emit(Events.STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating the current story's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.previousStory`\n    const {\n      initialArgs\n    } = storyId === this.previousStory.id ? this.previousStory : await this.storyStore.loadStory({\n      storyId\n    });\n    const argNamesToReset = argNames || Object.keys(this.storyStore.args.get(storyId));\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = initialArgs[argName];\n      return acc;\n    }, {});\n    this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  }\n\n  async onStoryIndexChanged() {\n    const storyIndex = await this.indexClient.fetch();\n    return this.onStoriesChanged({\n      storyIndex\n    });\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (this.urlStore.selection) {\n      this.renderSelection();\n    } else {\n      this.selectSpecifiedStory();\n    }\n\n    if (!(FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7)) {\n      this.channel.emit(Events.SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n  } // This happens when a config file gets reloade\n\n\n  onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    const projectAnnotations = this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!projectAnnotations) {\n      return;\n    }\n\n    this.storyStore.updateProjectAnnotations(projectAnnotations);\n    this.renderSelection();\n  } // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    var _this$previousSelecti, _this$previousSelecti2;\n\n    if (!this.urlStore.selection) {\n      throw new Error('Cannot render story as no selection was made');\n    }\n\n    const {\n      selection\n    } = this.urlStore;\n    let story;\n\n    try {\n      story = await this.storyStore.loadStory({\n        storyId: selection.storyId\n      });\n    } catch (err) {\n      this.previousStory = null;\n      logger.warn(err);\n      this.renderMissingStory(selection.storyId);\n      return;\n    }\n\n    const storyChanged = ((_this$previousSelecti = this.previousSelection) === null || _this$previousSelecti === void 0 ? void 0 : _this$previousSelecti.storyId) !== selection.storyId;\n    const viewModeChanged = ((_this$previousSelecti2 = this.previousSelection) === null || _this$previousSelecti2 === void 0 ? void 0 : _this$previousSelecti2.viewMode) !== selection.viewMode;\n    const implementationChanged = !storyChanged && this.previousStory && story !== this.previousStory;\n\n    if (persistedArgs) {\n      this.storyStore.args.updateFromPersisted(story, persistedArgs);\n    } else if (implementationChanged) {\n      this.storyStore.args.resetOnImplementationChange(story, this.previousStory);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (this.previousStory && !storyChanged && !implementationChanged && !viewModeChanged) {\n      this.channel.emit(Events.STORY_UNCHANGED, selection.storyId);\n      return;\n    }\n\n    this.cleanupPreviousRender({\n      unmountDocs: viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (this.previousSelection && (storyChanged || viewModeChanged)) {\n      this.channel.emit(Events.STORY_CHANGED, selection.storyId);\n    } // Record the previous selection *before* awaiting the rendering, in cases things change before it is done.\n\n\n    this.previousSelection = selection;\n    this.previousStory = story;\n    const {\n      parameters,\n      initialArgs,\n      argTypes,\n      args\n    } = this.storyStore.getStoryContext(story);\n\n    if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n      this.channel.emit(Events.STORY_PREPARED, {\n        id: story.id,\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      });\n    }\n\n    if (selection.viewMode === 'docs' || story.parameters.docsOnly) {\n      this.previousCleanup = await this.renderDocs({\n        story\n      });\n    } else {\n      this.previousCleanup = this.renderStory({\n        story\n      });\n    }\n  }\n\n  async renderDocs({\n    story\n  }) {\n    var _global$FEATURES;\n\n    const {\n      id,\n      title,\n      name,\n      componentId\n    } = story;\n    const element = this.view.prepareForDocs();\n    const csfFile = await this.storyStore.loadCSFFileByStoryId(id, {\n      sync: false\n    });\n    const renderingStoryPromises = [];\n    const docsContext = {\n      id,\n      title,\n      name,\n      // NOTE: these two functions are *sync* so cannot access stories from other CSF files\n      storyById: storyId => this.storyStore.storyFromCSFFile({\n        storyId,\n        csfFile\n      }),\n      componentStories: () => this.storyStore.componentStoriesFromCSFFile({\n        csfFile\n      }),\n      loadStory: storyId => this.storyStore.loadStory({\n        storyId\n      }),\n      renderStoryToElement: this.renderStoryToElement.bind(this),\n      // Keep track of the stories that are rendered by the <Story/> component and don't emit\n      // the DOCS_RENDERED event(below) until they have all marked themselves as rendered.\n      registerRenderingStory: () => {\n        let rendered;\n        renderingStoryPromises.push(new Promise(resolve => {\n          rendered = resolve;\n        }));\n        return rendered;\n      },\n      getStoryContext: renderedStory => Object.assign({}, this.storyStore.getStoryContext(renderedStory), {\n        viewMode: 'docs'\n      })\n    };\n    const {\n      docs\n    } = story.parameters;\n\n    if (docs !== null && docs !== void 0 && docs.page && !(docs !== null && docs !== void 0 && docs.container)) {\n      throw new Error('No `docs.container` set, did you run `addon-docs/preset`?');\n    }\n\n    const DocsContainer = docs.container || (({\n      children\n    }) => /*#__PURE__*/React.createElement(React.Fragment, null, children));\n\n    const Page = docs.page || NoDocs;\n\n    const render = () => {\n      // Use `componentId` as a key so that we force a re-render every time\n      // we switch components\n      const docsElement = /*#__PURE__*/React.createElement(DocsContainer, {\n        key: componentId,\n        context: docsContext\n      }, /*#__PURE__*/React.createElement(Page, null));\n      ReactDOM.render(docsElement, element, async () => {\n        await Promise.all(renderingStoryPromises);\n        this.channel.emit(Events.DOCS_RENDERED, id);\n      });\n    }; // Initially render right away\n\n\n    render(); // Listen to events and re-render\n    // NOTE: we aren't checking to see the story args are targetted at the \"right\" story.\n    // This is because we may render >1 story on the page and there is no easy way to keep track\n    // of which ones were rendered by the docs page.\n    // However, in `modernInlineRender`, the individual stories track their own events as they\n    // each call `renderStoryToElement` below.\n\n    if (!(global !== null && global !== void 0 && (_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.modernInlineRender)) {\n      this.channel.on(Events.UPDATE_GLOBALS, render);\n      this.channel.on(Events.UPDATE_STORY_ARGS, render);\n      this.channel.on(Events.RESET_STORY_ARGS, render);\n    }\n\n    return () => {\n      var _global$FEATURES2;\n\n      if (!(global !== null && global !== void 0 && (_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.modernInlineRender)) {\n        this.channel.off(Events.UPDATE_GLOBALS, render);\n        this.channel.off(Events.UPDATE_STORY_ARGS, render);\n        this.channel.off(Events.RESET_STORY_ARGS, render);\n      }\n    };\n  }\n\n  renderStory({\n    story\n  }) {\n    const element = this.view.prepareForStory(story);\n    const {\n      id,\n      componentId,\n      title,\n      name\n    } = story;\n    const renderContext = {\n      componentId,\n      title,\n      kind: title,\n      id,\n      name,\n      story: name,\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(err),\n      showException: err => this.renderException(err)\n    };\n    return this.renderStoryToElement({\n      story,\n      renderContext,\n      element\n    });\n  } // Render a story into a given element and watch for the events that would trigger us\n  // to re-render it (plus deal sensibly with things like changing story mid-way through).\n\n\n  renderStoryToElement({\n    story,\n    renderContext: renderContextWithoutStoryContext,\n    element\n  }) {\n    const {\n      id,\n      applyLoaders,\n      unboundStoryFn,\n      runPlayFunction\n    } = story; // IE11 doesn't support AbortController, so we either need to polyfill or just not support it\n\n    const controller = AbortController ? new AbortController() : {\n      signal: {\n        aborted: false\n      },\n\n      abort() {\n        this.signal.aborted = true;\n      }\n\n    };\n    let initialRenderPhase = 'init';\n    let renderContext;\n\n    const initialRender = async () => {\n      const storyContext = this.storyStore.getStoryContext(story);\n      const viewMode = element === this.view.storyRoot() ? 'story' : 'docs';\n      const loadedContext = await applyLoaders(Object.assign({}, storyContext, {\n        viewMode\n      }));\n\n      if (controller.signal.aborted) {\n        return;\n      }\n\n      initialRenderPhase = 'loaded'; // By this stage, it is possible that new args/globals have been received for this story\n      // and we need to ensure we render it with the new values\n\n      const updatedStoryContext = Object.assign({}, loadedContext, this.storyStore.getStoryContext(story));\n      renderContext = Object.assign({}, renderContextWithoutStoryContext, {\n        // Whenever the selection changes we want to force the component to be remounted.\n        forceRemount: true,\n        storyContext: updatedStoryContext,\n        storyFn: () => unboundStoryFn(updatedStoryContext),\n        unboundStoryFn\n      });\n      await this.renderToDOM(renderContext, element);\n\n      if (controller.signal.aborted) {\n        return;\n      }\n\n      initialRenderPhase = 'rendered'; // NOTE: if the story is torn down during the play function, there could be negative\n      // side-effects (as the play function tries to modify something that is no longer visible).\n      // In the future we will likely pass the AbortController signal into play(), and also\n      // attempt to scope the play function by passing the element.\n      //\n      // NOTE: it is possible that args/globals have changed in between us starting to render\n      // the story and executing the play function (it is also possible that they change mid-way\n      // through executing the play function). We explicitly allow such changes to re-render the\n      // story by setting `initialRenderDone=true` immediate after `renderToDOM` completes.\n\n      await runPlayFunction();\n\n      if (controller.signal.aborted) {\n        return;\n      }\n\n      initialRenderPhase = 'done';\n      this.channel.emit(Events.STORY_RENDERED, id);\n    }; // Setup a callback to run when the story needs to be re-rendered due to args or globals changes\n    // We need to be careful for race conditions if the initial rendering of the story (which\n    // can take some time due to loaders + the play function) hasn't completed yet.\n    // Our current approach is to either stop, or rerender immediately depending on which phase\n    // the initial render is in (see comments below).\n    // An alternative approach would be to *wait* until the initial render is done, before\n    // re-rendering with the new args. This would be relatively easy if we tracked the initial\n    // render via awaiting result of the call to `initialRender`. (We would also need to track\n    // if a subsequent *re-render* is in progress, but that is less likely)\n    // See also the note about cancelling below.\n\n\n    const rerenderStory = async () => {\n      // The story has not finished rendered the first time. The loaders are still running\n      // and we will pick up the new args/globals values when renderToDOM is called.\n      if (initialRenderPhase === 'init') {\n        return;\n      } // This story context will have the updated values of args and globals\n\n\n      const rerenderStoryContext = Object.assign({}, renderContext.storyContext, this.storyStore.getStoryContext(story));\n      const rerenderRenderContext = Object.assign({}, renderContext, {\n        forceRemount: false,\n        storyContext: rerenderStoryContext,\n        storyFn: () => unboundStoryFn(rerenderStoryContext)\n      });\n\n      try {\n        await this.renderToDOM(rerenderRenderContext, element);\n      } catch (err) {\n        renderContextWithoutStoryContext.showException(err);\n        return;\n      }\n\n      this.channel.emit(Events.STORY_RENDERED, id);\n    }; // Start the first render\n    // NOTE: we don't await here because we need to return the \"cleanup\" function below\n    // right away, so if the user changes story during the first render we can cancel\n    // it without having to first wait for it to finish.\n\n\n    initialRender().catch(err => renderContextWithoutStoryContext.showException(err)); // Listen to events and re-render story\n\n    this.channel.on(Events.UPDATE_GLOBALS, rerenderStory);\n    this.channel.on(Events.FORCE_RE_RENDER, rerenderStory);\n\n    const rerenderStoryIfMatches = async ({\n      storyId\n    }) => {\n      if (storyId === story.id) rerenderStory();\n    };\n\n    this.channel.on(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n    this.channel.on(Events.RESET_STORY_ARGS, rerenderStoryIfMatches);\n    return () => {\n      // If the story is torn down (either a new story is rendered or the docs page removes it)\n      // we need to consider the fact that the initial render may not be finished\n      // (possibly the loaders or the play function are still running). We use the controller\n      // as a method to abort them, ASAP, but this is not foolproof as we cannot control what\n      // happens inside the user's code. Still, we do render the new story right away.\n      // Alternatively, we could make this function async and await the teardown before rendering\n      // the new story. This might be a bit complicated for docs however.\n      controller.abort();\n      this.storyStore.cleanupStory(story);\n      this.channel.off(Events.UPDATE_GLOBALS, rerenderStory);\n      this.channel.off(Events.FORCE_RE_RENDER, rerenderStory);\n      this.channel.off(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n      this.channel.off(Events.RESET_STORY_ARGS, rerenderStoryIfMatches);\n    };\n  }\n\n  cleanupPreviousRender({\n    unmountDocs = true\n  } = {}) {\n    var _this$previousStory, _this$previousStory$p, _this$previousSelecti3;\n\n    const previousViewMode = (_this$previousStory = this.previousStory) !== null && _this$previousStory !== void 0 && (_this$previousStory$p = _this$previousStory.parameters) !== null && _this$previousStory$p !== void 0 && _this$previousStory$p.docsOnly ? 'docs' : (_this$previousSelecti3 = this.previousSelection) === null || _this$previousSelecti3 === void 0 ? void 0 : _this$previousSelecti3.viewMode;\n\n    if (unmountDocs && previousViewMode === 'docs') {\n      ReactDOM.unmountComponentAtNode(this.view.docsRoot());\n    }\n\n    if (previousViewMode) {\n      this.previousCleanup();\n    }\n  }\n\n  renderPreviewEntryError(err) {\n    this.view.showErrorDisplay(err);\n    this.channel.emit(Events.CONFIG_ERROR, err);\n  }\n\n  renderMissingStory(storySpecifier) {\n    this.cleanupPreviousRender();\n    this.view.showNoPreview();\n    this.channel.emit(Events.STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(err) {\n    this.view.showErrorDisplay(err);\n    this.channel.emit(Events.STORY_THREW_EXCEPTION, err); // Log the stack to the console. So, user could check the source code.\n\n    logger.error(err);\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError({\n    title,\n    description\n  }) {\n    this.channel.emit(Events.STORY_ERRORED, {\n      title,\n      description\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import \"core-js/modules/web.immediate.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\n\nconst generateRandomId = () => {\n  // generates a random 13 character string\n  return Math.random().toString(16).slice(2);\n};\n\nexport class Channel {\n  constructor({\n    transport,\n    async = false\n  } = {}) {\n    this.isAsync = void 0;\n    this.sender = generateRandomId();\n    this.events = {};\n    this.data = {};\n    this.transport = void 0;\n    this.addPeerListener = deprecate((eventName, listener) => {\n      this.addListener(eventName, listener);\n    }, dedent`\n      channel.addPeerListener is deprecated\n    `);\n    this.isAsync = async;\n\n    if (transport) {\n      this.transport = transport;\n      this.transport.setHandler(event => this.handleEvent(event));\n    }\n  }\n\n  get hasTransport() {\n    return !!this.transport;\n  }\n\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(listener);\n  }\n\n  emit(eventName, ...args) {\n    const event = {\n      type: eventName,\n      args,\n      from: this.sender\n    };\n    let options = {};\n\n    if (args.length >= 1 && args[0] && args[0].options) {\n      options = args[0].options;\n    }\n\n    const handler = () => {\n      if (this.transport) {\n        this.transport.send(event, options);\n      }\n\n      this.handleEvent(event);\n    };\n\n    if (this.isAsync) {\n      // todo I'm not sure how to test this\n      setImmediate(handler);\n    } else {\n      handler();\n    }\n  }\n\n  last(eventName) {\n    return this.data[eventName];\n  }\n\n  eventNames() {\n    return Object.keys(this.events);\n  }\n\n  listenerCount(eventName) {\n    const listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n\n  listeners(eventName) {\n    const listeners = this.events[eventName];\n    return listeners || undefined;\n  }\n\n  once(eventName, listener) {\n    const onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n\n  removeAllListeners(eventName) {\n    if (!eventName) {\n      this.events = {};\n    } else if (this.events[eventName]) {\n      delete this.events[eventName];\n    }\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this.listeners(eventName);\n\n    if (listeners) {\n      this.events[eventName] = listeners.filter(l => l !== listener);\n    }\n  }\n\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n\n  handleEvent(event) {\n    const listeners = this.listeners(event.type);\n\n    if (listeners && listeners.length) {\n      listeners.forEach(fn => {\n        fn.apply(event, event.args);\n      });\n    }\n\n    this.data[event.type] = event.args;\n  }\n\n  onceListener(eventName, listener) {\n    const onceListener = (...args) => {\n      this.removeListener(eventName, onceListener);\n      return listener(...args);\n    };\n\n    return onceListener;\n  }\n\n}\nexport default Channel;","function _EMOTION_STRINGIFIED_CSS_ERROR__() { return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\"; }\n\nimport { css, keyframes } from '@emotion/core';\nexport const easing = {\n  rubber: 'cubic-bezier(0.175, 0.885, 0.335, 1.05)'\n};\nconst rotate360 = keyframes`\n\tfrom {\n\t\ttransform: rotate(0deg);\n\t}\n\tto {\n\t\ttransform: rotate(360deg);\n\t}\n`;\nconst glow = keyframes`\n  0%, 100% { opacity: 1; }\n  50% { opacity: .4; }\n`;\nconst float = keyframes`\n  0% { transform: translateY(1px); }\n  25% { transform: translateY(0px); }\n  50% { transform: translateY(-3px); }\n  100% { transform: translateY(1px); }\n`;\nconst jiggle = keyframes`\n  0%, 100% { transform:translate3d(0,0,0); }\n  12.5%, 62.5% { transform:translate3d(-4px,0,0); }\n  37.5%, 87.5% {  transform: translate3d(4px,0,0);  }\n`;\nconst inlineGlow = /*#__PURE__*/css(\"animation:\", glow, \" 1.5s ease-in-out infinite;color:transparent;cursor:progress;;label:inlineGlow;\" + (process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbmltYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUNzQiIsImZpbGUiOiIuLi8uLi9zcmMvYW5pbWF0aW9uLnRzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3NzLCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcblxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcbiAgcnViYmVyOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMzUsIDEuMDUpJyxcbn07XG5cbmNvbnN0IHJvdGF0ZTM2MCA9IGtleWZyYW1lc2Bcblx0ZnJvbSB7XG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdH1cblx0dG8ge1xuXHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdH1cbmA7XG5cbmNvbnN0IGdsb3cgPSBrZXlmcmFtZXNgXG4gIDAlLCAxMDAlIHsgb3BhY2l0eTogMTsgfVxuICA1MCUgeyBvcGFjaXR5OiAuNDsgfVxuYDtcblxuY29uc3QgZmxvYXQgPSBrZXlmcmFtZXNgXG4gIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDFweCk7IH1cbiAgMjUlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7IH1cbiAgNTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpOyB9XG4gIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTsgfVxuYDtcblxuY29uc3QgamlnZ2xlID0ga2V5ZnJhbWVzYFxuICAwJSwgMTAwJSB7IHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7IH1cbiAgMTIuNSUsIDYyLjUlIHsgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00cHgsMCwwKTsgfVxuICAzNy41JSwgODcuNSUgeyAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg0cHgsMCwwKTsgIH1cbmA7XG5cbmNvbnN0IGlubGluZUdsb3cgPSBjc3NgXG4gIGFuaW1hdGlvbjogJHtnbG93fSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcHJvZ3Jlc3M7XG5gO1xuXG4vLyBob3ZlciAmIGFjdGl2ZSBzdGF0ZSBmb3IgbGlua3MgYW5kIGJ1dHRvbnNcbmNvbnN0IGhvdmVyYWJsZSA9IGNzc2BcbiAgdHJhbnNpdGlvbjogYWxsIDE1MG1zIGVhc2Utb3V0O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXG4gICY6aG92ZXIge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTJweCwgMCk7XG4gIH1cblxuICAmOmFjdGl2ZSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IHtcbiAgcm90YXRlMzYwLFxuICBnbG93LFxuICBmbG9hdCxcbiAgamlnZ2xlLFxuICBpbmxpbmVHbG93LFxuICBob3ZlcmFibGUsXG59O1xuIl19 */\")); // hover & active state for links and buttons\n\nconst hoverable = process.env.NODE_ENV === \"production\" ? {\n  name: \"1o7rzh8-hoverable\",\n  styles: \"transition:all 150ms ease-out;transform:translate3d(0,0,0);&:hover{transform:translate3d(0,-2px,0);}&:active{transform:translate3d(0,0,0);};label:hoverable;\"\n} : {\n  name: \"1o7rzh8-hoverable\",\n  styles: \"transition:all 150ms ease-out;transform:translate3d(0,0,0);&:hover{transform:translate3d(0,-2px,0);}&:active{transform:translate3d(0,0,0);};label:hoverable;\",\n  map: \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbmltYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0NxQiIsImZpbGUiOiIuLi8uLi9zcmMvYW5pbWF0aW9uLnRzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3NzLCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcblxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcbiAgcnViYmVyOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMzUsIDEuMDUpJyxcbn07XG5cbmNvbnN0IHJvdGF0ZTM2MCA9IGtleWZyYW1lc2Bcblx0ZnJvbSB7XG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdH1cblx0dG8ge1xuXHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdH1cbmA7XG5cbmNvbnN0IGdsb3cgPSBrZXlmcmFtZXNgXG4gIDAlLCAxMDAlIHsgb3BhY2l0eTogMTsgfVxuICA1MCUgeyBvcGFjaXR5OiAuNDsgfVxuYDtcblxuY29uc3QgZmxvYXQgPSBrZXlmcmFtZXNgXG4gIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDFweCk7IH1cbiAgMjUlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7IH1cbiAgNTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpOyB9XG4gIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTsgfVxuYDtcblxuY29uc3QgamlnZ2xlID0ga2V5ZnJhbWVzYFxuICAwJSwgMTAwJSB7IHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7IH1cbiAgMTIuNSUsIDYyLjUlIHsgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00cHgsMCwwKTsgfVxuICAzNy41JSwgODcuNSUgeyAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg0cHgsMCwwKTsgIH1cbmA7XG5cbmNvbnN0IGlubGluZUdsb3cgPSBjc3NgXG4gIGFuaW1hdGlvbjogJHtnbG93fSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcHJvZ3Jlc3M7XG5gO1xuXG4vLyBob3ZlciAmIGFjdGl2ZSBzdGF0ZSBmb3IgbGlua3MgYW5kIGJ1dHRvbnNcbmNvbnN0IGhvdmVyYWJsZSA9IGNzc2BcbiAgdHJhbnNpdGlvbjogYWxsIDE1MG1zIGVhc2Utb3V0O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXG4gICY6aG92ZXIge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTJweCwgMCk7XG4gIH1cblxuICAmOmFjdGl2ZSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IHtcbiAgcm90YXRlMzYwLFxuICBnbG93LFxuICBmbG9hdCxcbiAgamlnZ2xlLFxuICBpbmxpbmVHbG93LFxuICBob3ZlcmFibGUsXG59O1xuIl19 */\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\nexport const animation = {\n  rotate360,\n  glow,\n  float,\n  jiggle,\n  inlineGlow,\n  hoverable\n};"],"names":[],"sourceRoot":""}