{"version":3,"file":"219.eb14cc5d.iframe.bundle.js","mappings":";;AA4DA;;AAEA;;;;;AAQA;ACnDA;;AAEA;;AAIA;;AAYA;;;;AA4DA;;;;AAYA;;;;;;;;;;;;;;;;;;;;;AChCA;;;;AClBA;;;;;;;AC3DA;;;;;AA0FA;;;;ACvCA;ACsCA;;;AAIA;AAMA;;;AAIA;;;AC/FA;;;;;ACGA;;;ACMA;ACQA;;;;;AAMA;;;;ACqCA;ACqCA;;;;ACxBA;;;;;;AAuCA;;;;AAmGA;AACA;;;;AAuBA;;AAmgBA;;AC9tBA;;;;;;;ACVA;;;AA0BA;;;;;AAIA;;;;AACA;;;;ACvCA;;;;ACAA;;;;ACDA;;;;AAMA","sources":["webpack://origami-storybook/./node_modules/@storybook/client-api/dist/modern/StoryStoreFacade.js","webpack://origami-storybook/./node_modules/@storybook/client-api/dist/modern/ClientApi.js","webpack://origami-storybook/./node_modules/@storybook/components/dist/modern/controls/options/Select.js","webpack://origami-storybook/./node_modules/@storybook/components/dist/modern/controls/options/Options.js","webpack://origami-storybook/./node_modules/@storybook/components/dist/modern/Loader/Loader.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/StoryIndexStore.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/args.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/GlobalsStore.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/normalizeStory.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/prepareStory.js","webpack://origami-storybook/./node_modules/@storybook/store/dist/modern/inferArgTypes.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/parseArgsParam.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/WebView.js","webpack://origami-storybook/./node_modules/@storybook/preview-web/dist/modern/PreviewWeb.js","webpack://origami-storybook/./node_modules/@storybook/channels/dist/modern/index.js","webpack://origami-storybook/./node_modules/@storybook/theming/dist/modern/animation.js","webpack://origami-storybook/../../node_modules/@storybook/addon-docs/dist/modern/blocks/Stories.js","webpack://origami-storybook/../../node_modules/@storybook/addon-docs/dist/modern/blocks/Meta.js","webpack://origami-storybook/../../node_modules/@storybook/addon-docs/dist/modern/blocks/Props.js"],"sourcesContent":["function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport \"core-js/modules/es.array.reduce.js\";\nimport global from 'global';\nimport dedent from 'ts-dedent';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport { toId, isExportStory, storyNameFromExport } from '@storybook/csf';\nimport { autoTitle, sortStoriesV6 } from '@storybook/store';\nimport { logger } from '@storybook/client-logger';\nexport class StoryStoreFacade {\n  constructor() {\n    this.projectAnnotations = void 0;\n    this.stories = void 0;\n    this.csfExports = void 0;\n    this.projectAnnotations = {\n      loaders: [],\n      decorators: [],\n      parameters: {},\n      argsEnhancers: [],\n      argTypesEnhancers: []\n    };\n    this.stories = {};\n    this.csfExports = {};\n  } // This doesn't actually import anything because the client-api loads fully\n  // on startup, but this is a shim after all.\n\n\n  importFn(path) {\n    return SynchronousPromise.resolve().then(() => {\n      const moduleExports = this.csfExports[path];\n      if (!moduleExports) throw new Error(`Unknown path: ${path}`);\n      return moduleExports;\n    });\n  }\n\n  getStoryIndex(store) {\n    var _this$projectAnnotati, _this$projectAnnotati2;\n\n    const fileNameOrder = Object.keys(this.csfExports);\n    const storySortParameter = (_this$projectAnnotati = this.projectAnnotations.parameters) === null || _this$projectAnnotati === void 0 ? void 0 : (_this$projectAnnotati2 = _this$projectAnnotati.options) === null || _this$projectAnnotati2 === void 0 ? void 0 : _this$projectAnnotati2.storySort;\n    const storyEntries = Object.entries(this.stories); // Add the kind parameters and global parameters to each entry\n\n    const sortableV6 = storyEntries.map(([storyId, {\n      importPath\n    }]) => {\n      const exports = this.csfExports[importPath];\n      const csfFile = store.processCSFFileWithCache(exports, importPath, exports.default.title);\n      return [storyId, store.storyFromCSFFile({\n        storyId,\n        csfFile\n      }), csfFile.meta.parameters, this.projectAnnotations.parameters];\n    }); // NOTE: the sortStoriesV6 version returns the v7 data format. confusing but more convenient!\n\n    let sortedV7;\n\n    try {\n      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);\n    } catch (err) {\n      if (typeof storySortParameter === 'function') {\n        throw new Error(dedent`\n          Error sorting stories with sort parameter ${storySortParameter}:\n\n          > ${err.message}\n          \n          Are you using a V7-style sort function in V6 compatibility mode?\n          \n          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n        `);\n      }\n\n      throw err;\n    }\n\n    const stories = sortedV7.reduce((acc, s) => {\n      // We use the original entry we stored in `this.stories` because it is possible that the CSF file itself\n      // exports a `parameters.fileName` which can be different and mess up our `importFn`.\n      // In fact, in Storyshots there is a Jest transformer that does exactly that.\n      // NOTE: this doesn't actually change the story object, just the index.\n      acc[s.id] = this.stories[s.id];\n      return acc;\n    }, {});\n    return {\n      v: 3,\n      stories\n    };\n  }\n\n  clearFilenameExports(fileName) {\n    if (!this.csfExports[fileName]) {\n      return;\n    } // Clear this module's stories from the storyList and existing exports\n\n\n    Object.entries(this.stories).forEach(([id, {\n      importPath\n    }]) => {\n      if (importPath === fileName) {\n        delete this.stories[id];\n      }\n    }); // We keep this as an empty record so we can use it to maintain component order\n\n    this.csfExports[fileName] = {};\n  } // NOTE: we could potentially share some of this code with the stories.json generation\n\n\n  addStoriesFromExports(fileName, fileExports) {\n    // if the export haven't changed since last time we added them, this is a no-op\n    if (this.csfExports[fileName] === fileExports) {\n      return;\n    } // OTOH, if they have changed, let's clear them out first\n\n\n    this.clearFilenameExports(fileName);\n\n    const {\n      default: defaultExport,\n      __namedExportsOrder\n    } = fileExports,\n          namedExports = _objectWithoutPropertiesLoose(fileExports, [\"default\", \"__namedExportsOrder\"]); // eslint-disable-next-line prefer-const\n\n\n    let {\n      id: componentId,\n      title\n    } = defaultExport || {};\n    title = title || autoTitle(fileName, (global.STORIES || []).map(specifier => Object.assign({}, specifier, {\n      importPathMatcher: new RegExp(specifier.importPathMatcher)\n    })));\n\n    if (!title) {\n      logger.info(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);\n      return;\n    }\n\n    this.csfExports[fileName] = Object.assign({}, fileExports, {\n      default: Object.assign({}, defaultExport, {\n        title\n      })\n    });\n    let sortedExports = namedExports; // prefer a user/loader provided `__namedExportsOrder` array if supplied\n    // we do this as es module exports are always ordered alphabetically\n    // see https://github.com/storybookjs/storybook/issues/9136\n\n    if (Array.isArray(__namedExportsOrder)) {\n      sortedExports = {};\n\n      __namedExportsOrder.forEach(name => {\n        const namedExport = namedExports[name];\n        if (namedExport) sortedExports[name] = namedExport;\n      });\n    }\n\n    Object.entries(sortedExports).filter(([key]) => isExportStory(key, defaultExport)).forEach(([key, storyExport]) => {\n      var _storyExport$paramete, _storyExport$story;\n\n      const exportName = storyNameFromExport(key);\n      const id = ((_storyExport$paramete = storyExport.parameters) === null || _storyExport$paramete === void 0 ? void 0 : _storyExport$paramete.__id) || toId(componentId || title, exportName);\n      const name = typeof storyExport !== 'function' && storyExport.name || storyExport.storyName || ((_storyExport$story = storyExport.story) === null || _storyExport$story === void 0 ? void 0 : _storyExport$story.name) || exportName;\n      this.stories[id] = {\n        id,\n        name,\n        title,\n        importPath: fileName\n      };\n    });\n  }\n\n}","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport { toId, sanitize } from '@storybook/csf';\nimport { combineParameters, normalizeInputTypes } from '@storybook/store';\nimport { StoryStoreFacade } from './StoryStoreFacade';\n// ClientApi (and StoreStore) are really singletons. However they are not created until the\n// relevant framework instanciates them via `start.js`. The good news is this happens right away.\nlet singleton;\nconst warningAlternatives = {\n  addDecorator: `Instead, use \\`export const decorators = [];\\` in your \\`preview.js\\`.`,\n  addParameters: `Instead, use \\`export const parameters = {};\\` in your \\`preview.js\\`.`,\n  addLoaders: `Instead, use \\`export const loaders = [];\\` in your \\`preview.js\\`.`\n};\n\nconst warningMessage = method => deprecate(() => {}, dedent`\n  \\`${method}\\` is deprecated, and will be removed in Storybook 7.0.\n\n  ${warningAlternatives[method]}\n\n  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`);\n\nconst warnings = {\n  addDecorator: warningMessage('addDecorator'),\n  addParameters: warningMessage('addParameters'),\n  addLoaders: warningMessage('addLoaders')\n};\n\nconst checkMethod = (method, deprecationWarning) => {\n  var _global$FEATURES;\n\n  if ((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.storyStoreV7) {\n    throw new Error(dedent`You cannot use \\`${method}\\` with the new Story Store.\n      \n      ${warningAlternatives[method]}`);\n  }\n\n  if (!singleton) {\n    throw new Error(`Singleton client API not yet initialized, cannot call \\`${method}\\`.`);\n  }\n\n  if (deprecationWarning) {\n    warnings[method]();\n  }\n};\n\nexport const addDecorator = (decorator, deprecationWarning = true) => {\n  checkMethod('addDecorator', deprecationWarning);\n  singleton.addDecorator(decorator);\n};\nexport const addParameters = (parameters, deprecationWarning = true) => {\n  checkMethod('addParameters', deprecationWarning);\n  singleton.addParameters(parameters);\n};\nexport const addLoader = (loader, deprecationWarning = true) => {\n  checkMethod('addLoader', deprecationWarning);\n  singleton.addLoader(loader);\n};\nexport const addArgsEnhancer = enhancer => {\n  checkMethod('addArgsEnhancer', false);\n  singleton.addArgsEnhancer(enhancer);\n};\nexport const addArgTypesEnhancer = enhancer => {\n  checkMethod('addArgTypesEnhancer', false);\n  singleton.addArgTypesEnhancer(enhancer);\n};\nexport const getGlobalRender = () => {\n  checkMethod('getGlobalRender', false);\n  return singleton.facade.projectAnnotations.render;\n};\nexport const setGlobalRender = render => {\n  checkMethod('setGlobalRender', false);\n  singleton.facade.projectAnnotations.render = render;\n};\nconst invalidStoryTypes = new Set(['string', 'number', 'boolean', 'symbol']);\nexport class ClientApi {\n  // If we don't get passed modules so don't know filenames, we can\n  // just use numeric indexes\n  constructor({\n    storyStore\n  } = {}) {\n    this.facade = void 0;\n    this.storyStore = void 0;\n    this.addons = void 0;\n    this.onImportFnChanged = void 0;\n    this.lastFileName = 0;\n    this.setAddon = deprecate(addon => {\n      this.addons = Object.assign({}, this.addons, addon);\n    }, dedent`\n      \\`setAddon\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon\n    `);\n\n    this.addDecorator = decorator => {\n      this.facade.projectAnnotations.decorators.push(decorator);\n    };\n\n    this.clearDecorators = deprecate(() => {\n      this.facade.projectAnnotations.decorators = [];\n    }, dedent`\n      \\`clearDecorators\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators\n    `);\n\n    this.addParameters = (_ref) => {\n      let {\n        globals,\n        globalTypes\n      } = _ref,\n          parameters = _objectWithoutPropertiesLoose(_ref, [\"globals\", \"globalTypes\"]);\n\n      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters);\n\n      if (globals) {\n        this.facade.projectAnnotations.globals = Object.assign({}, this.facade.projectAnnotations.globals, globals);\n      }\n\n      if (globalTypes) {\n        this.facade.projectAnnotations.globalTypes = Object.assign({}, this.facade.projectAnnotations.globalTypes, normalizeInputTypes(globalTypes));\n      }\n    };\n\n    this.addLoader = loader => {\n      this.facade.projectAnnotations.loaders.push(loader);\n    };\n\n    this.addArgsEnhancer = enhancer => {\n      this.facade.projectAnnotations.argsEnhancers.push(enhancer);\n    };\n\n    this.addArgTypesEnhancer = enhancer => {\n      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);\n    };\n\n    this.storiesOf = (kind, m) => {\n      if (!kind && typeof kind !== 'string') {\n        throw new Error('Invalid or missing kind provided for stories, should be a string');\n      }\n\n      if (!m) {\n        logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`);\n      }\n\n      if (m) {\n        const proto = Object.getPrototypeOf(m);\n\n        if (proto.exports && proto.exports.default) {\n          // FIXME: throw an error in SB6.0\n          logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);\n        }\n      } // eslint-disable-next-line no-plusplus\n\n\n      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();\n      let fileName = baseFilename;\n      let i = 1; // Deal with `storiesOf()` being called twice in the same file.\n      // On HMR, `this.csfExports[fileName]` will be reset to `{}`, so an empty object is due\n      // to this export, not a second call of `storiesOf()`.\n\n      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {\n        i += 1;\n        fileName = `${baseFilename}-${i}`;\n      }\n\n      if (m && m.hot && m.hot.accept) {\n        // This module used storiesOf(), so when it re-runs on HMR, it will reload\n        // itself automatically without us needing to look at our imports\n        m.hot.accept();\n        m.hot.dispose(() => {\n          this.facade.clearFilenameExports(fileName); // We need to update the importFn as soon as the module re-evaluates\n          // (and calls storiesOf() again, etc). We could call `onImportFnChanged()`\n          // at the end of every setStories call (somehow), but then we'd need to\n          // debounce it somehow for initial startup. Instead, we'll take advantage of\n          // the fact that the evaluation of the module happens immediately in the same tick\n\n          setTimeout(() => {\n            var _this$onImportFnChang;\n\n            (_this$onImportFnChang = this.onImportFnChanged) === null || _this$onImportFnChang === void 0 ? void 0 : _this$onImportFnChang.call(this, {\n              importFn: this.importFn.bind(this)\n            });\n          }, 0);\n        });\n      }\n\n      let hasAdded = false;\n      const api = {\n        kind: kind.toString(),\n        add: () => api,\n        addDecorator: () => api,\n        addLoader: () => api,\n        addParameters: () => api\n      }; // apply addons\n\n      Object.keys(this.addons).forEach(name => {\n        const addon = this.addons[name];\n\n        api[name] = (...args) => {\n          addon.apply(api, args);\n          return api;\n        };\n      });\n      const meta = {\n        id: sanitize(kind),\n        title: kind,\n        decorators: [],\n        loaders: [],\n        parameters: {}\n      }; // We map these back to a simple default export, even though we have type guarantees at this point\n\n      this.facade.csfExports[fileName] = {\n        default: meta\n      };\n      let counter = 0;\n\n      api.add = (storyName, storyFn, parameters = {}) => {\n        hasAdded = true;\n\n        if (typeof storyName !== 'string') {\n          throw new Error(`Invalid or missing storyName provided for a \"${kind}\" story.`);\n        }\n\n        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {\n          throw new Error(`Cannot load story \"${storyName}\" in \"${kind}\" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);\n        }\n\n        const {\n          decorators,\n          loaders,\n          component,\n          args,\n          argTypes\n        } = parameters,\n              storyParameters = _objectWithoutPropertiesLoose(parameters, [\"decorators\", \"loaders\", \"component\", \"args\", \"argTypes\"]); // eslint-disable-next-line no-underscore-dangle\n\n\n        const storyId = parameters.__id || toId(kind, storyName);\n        const csfExports = this.facade.csfExports[fileName]; // Whack a _ on the front incase it is \"default\"\n\n        csfExports[`story${counter}`] = {\n          name: storyName,\n          parameters: Object.assign({\n            fileName,\n            __id: storyId\n          }, storyParameters),\n          decorators,\n          loaders,\n          args,\n          argTypes,\n          component,\n          render: storyFn\n        };\n        counter += 1;\n        this.facade.stories[storyId] = {\n          id: storyId,\n          title: csfExports.default.title,\n          name: storyName,\n          importPath: fileName\n        };\n        return api;\n      };\n\n      api.addDecorator = decorator => {\n        if (hasAdded) throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.decorators.push(decorator);\n        return api;\n      };\n\n      api.addLoader = loader => {\n        if (hasAdded) throw new Error(`You cannot add a loader after the first story for a kind.`);\n        meta.loaders.push(loader);\n        return api;\n      };\n\n      api.addParameters = (_ref2) => {\n        let {\n          component,\n          args,\n          argTypes\n        } = _ref2,\n            parameters = _objectWithoutPropertiesLoose(_ref2, [\"component\", \"args\", \"argTypes\"]);\n\n        if (hasAdded) throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.parameters = combineParameters(meta.parameters, parameters);\n        if (component) meta.component = component;\n        if (args) meta.args = Object.assign({}, meta.args, args);\n        if (argTypes) meta.argTypes = Object.assign({}, meta.argTypes, argTypes);\n        return api;\n      };\n\n      return api;\n    };\n\n    this.getStorybook = () => {\n      const {\n        stories\n      } = this.storyStore.storyIndex;\n      const kinds = {};\n      Object.entries(stories).forEach(([storyId, {\n        title,\n        name,\n        importPath\n      }]) => {\n        if (!kinds[title]) {\n          kinds[title] = {\n            kind: title,\n            fileName: importPath,\n            stories: []\n          };\n        }\n\n        const {\n          storyFn\n        } = this.storyStore.fromId(storyId);\n        kinds[title].stories.push({\n          name,\n          render: storyFn\n        });\n      });\n      return Object.values(kinds);\n    };\n\n    this.raw = () => {\n      return this.storyStore.raw();\n    };\n\n    this.facade = new StoryStoreFacade();\n    this.addons = {};\n    this.storyStore = storyStore;\n    singleton = this;\n  }\n\n  importFn(path) {\n    return this.facade.importFn(path);\n  }\n\n  getStoryIndex() {\n    if (!this.storyStore) {\n      throw new Error('Cannot get story index before setting storyStore');\n    }\n\n    return this.facade.getStoryIndex(this.storyStore);\n  }\n\n  // @deprecated\n  get _storyStore() {\n    return this.storyStore;\n  }\n\n}","import React from 'react';\nimport { styled } from '@storybook/theming';\nimport { logger } from '@storybook/client-logger';\nimport { selectedKey, selectedKeys, selectedValues } from './helpers';\nimport { Icons } from '../../icon/icon';\nimport { getControlId } from '../helpers';\nconst styleResets = {\n  // resets\n  appearance: 'none',\n  border: '0 none',\n  boxSizing: 'inherit',\n  display: ' block',\n  margin: ' 0',\n  background: 'transparent',\n  padding: 0,\n  fontSize: 'inherit',\n  position: 'relative'\n};\nconst OptionsSelect = styled.select(({\n  theme\n}) => Object.assign({}, styleResets, {\n  boxSizing: 'border-box',\n  position: 'relative',\n  padding: '6px 10px',\n  width: '100%',\n  color: theme.input.color || 'inherit',\n  background: theme.input.background,\n  borderRadius: theme.input.borderRadius,\n  boxShadow: `${theme.input.border} 0 0 0 1px inset`,\n  fontSize: theme.typography.size.s2 - 1,\n  lineHeight: '20px',\n  '&:focus': {\n    boxShadow: `${theme.color.secondary} 0 0 0 1px inset`,\n    outline: 'none'\n  },\n  '&[disabled]': {\n    cursor: 'not-allowed',\n    opacity: 0.5\n  },\n  '::placeholder': {\n    color: theme.color.mediumdark\n  },\n  '&[multiple]': {\n    overflow: 'auto',\n    padding: 0,\n    option: {\n      display: 'block',\n      padding: '6px 10px',\n      marginLeft: 1,\n      marginRight: 1\n    }\n  }\n}));\nconst SelectWrapper = styled.span`\n  display: inline-block;\n  line-height: normal;\n  overflow: hidden;\n  position: relative;\n  vertical-align: top;\n  width: 100%;\n\n  svg {\n    position: absolute;\n    z-index: 1;\n    pointer-events: none;\n    height: 12px;\n    margin-top: -6px;\n    right: 12px;\n    top: 50%;\n\n    path {\n      fill: currentColor;\n    }\n  }\n`;\nconst NO_SELECTION = 'Choose option...';\n\nconst SingleSelect = ({\n  name,\n  value,\n  options,\n  onChange\n}) => {\n  const handleChange = e => {\n    onChange(options[e.currentTarget.value]);\n  };\n\n  const selection = selectedKey(value, options) || NO_SELECTION;\n  const controlId = getControlId(name);\n  return /*#__PURE__*/React.createElement(SelectWrapper, null, /*#__PURE__*/React.createElement(Icons, {\n    icon: \"arrowdown\"\n  }), /*#__PURE__*/React.createElement(OptionsSelect, {\n    id: controlId,\n    value: selection,\n    onChange: handleChange\n  }, /*#__PURE__*/React.createElement(\"option\", {\n    key: \"no-selection\",\n    disabled: true\n  }, NO_SELECTION), Object.keys(options).map(key => /*#__PURE__*/React.createElement(\"option\", {\n    key: key\n  }, key))));\n};\n\nSingleSelect.displayName = \"SingleSelect\";\n\nconst MultiSelect = ({\n  name,\n  value,\n  options,\n  onChange\n}) => {\n  const handleChange = e => {\n    const selection = Array.from(e.currentTarget.options).filter(option => option.selected).map(option => option.value);\n    onChange(selectedValues(selection, options));\n  };\n\n  const selection = selectedKeys(value, options);\n  const controlId = getControlId(name);\n  return /*#__PURE__*/React.createElement(SelectWrapper, null, /*#__PURE__*/React.createElement(OptionsSelect, {\n    id: controlId,\n    multiple: true,\n    value: selection,\n    onChange: handleChange\n  }, Object.keys(options).map(key => /*#__PURE__*/React.createElement(\"option\", {\n    key: key\n  }, key))));\n};\n\nMultiSelect.displayName = \"MultiSelect\";\nexport const SelectControl = props => {\n  const {\n    name,\n    options\n  } = props;\n\n  if (!options) {\n    logger.warn(`Select with no options: ${name}`);\n    return /*#__PURE__*/React.createElement(React.Fragment, null, \"-\");\n  } // eslint-disable-next-line react/destructuring-assignment\n\n\n  return props.isMulti ? /*#__PURE__*/React.createElement(MultiSelect, props) : /*#__PURE__*/React.createElement(SingleSelect, props);\n};","import \"core-js/modules/es.array.reduce.js\";\nimport React from 'react';\nimport dedent from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport { CheckboxControl } from './Checkbox';\nimport { RadioControl } from './Radio';\nimport { SelectControl } from './Select';\n\n/**\n * Options can accept `options` in two formats:\n * - array: ['a', 'b', 'c'] OR\n * - object: { a: 1, b: 2, c: 3 } (deprecated)\n *\n * We always normalize to the more generalized object format and ONLY handle\n * the object format in the underlying control implementations.\n *\n * While non-primitive values are deprecated, they might still not be valid\n * object keys, so the resulting object is a Label -> Value mapping.\n */\nconst normalizeOptions = (options, labels) => {\n  if (Array.isArray(options)) {\n    return options.reduce((acc, item) => {\n      acc[(labels === null || labels === void 0 ? void 0 : labels[item]) || String(item)] = item;\n      return acc;\n    }, {});\n  }\n\n  return options;\n};\n\nconst Controls = {\n  check: CheckboxControl,\n  'inline-check': CheckboxControl,\n  radio: RadioControl,\n  'inline-radio': RadioControl,\n  select: SelectControl,\n  'multi-select': SelectControl\n};\nexport const OptionsControl = props => {\n  const {\n    type = 'select',\n    options,\n    labels,\n    argType\n  } = props;\n  const normalized = Object.assign({}, props, {\n    options: normalizeOptions(options || argType.options, labels),\n    isInline: type.includes('inline'),\n    isMulti: type.includes('multi')\n  });\n\n  if (options) {\n    once.warn(dedent`\n      'control.options' is deprecated and will be removed in Storybook 7.0. Define 'options' directly on the argType instead, and use 'control.labels' for custom labels.\n\n      More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-controloptions\n    `);\n  }\n\n  const Control = Controls[type];\n\n  if (Control) {\n    return /*#__PURE__*/React.createElement(Control, normalized);\n  }\n\n  throw new Error(`Unknown options type: ${type}`);\n};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport global from 'global';\nimport { transparentize } from 'polished';\nimport React, { useEffect, useState } from 'react';\nimport { styled, keyframes } from '@storybook/theming';\nimport { Icons } from '../icon/icon';\nimport { rotate360 } from '../shared/animation';\nconst {\n  EventSource,\n  CONFIG_TYPE\n} = global;\nconst LoaderWrapper = styled.div(({\n  size = 32\n}) => ({\n  borderRadius: '50%',\n  cursor: 'progress',\n  display: 'inline-block',\n  overflow: 'hidden',\n  position: 'absolute',\n  transition: 'all 200ms ease-out',\n  verticalAlign: 'top',\n  top: '50%',\n  left: '50%',\n  marginTop: -(size / 2),\n  marginLeft: -(size / 2),\n  height: size,\n  width: size,\n  zIndex: 4,\n  borderWidth: 2,\n  borderStyle: 'solid',\n  borderColor: 'rgba(97, 97, 97, 0.29)',\n  borderTopColor: 'rgb(100,100,100)',\n  animation: `${rotate360} 0.7s linear infinite`,\n  mixBlendMode: 'difference'\n}));\nconst ProgressWrapper = styled.div({\n  position: 'absolute',\n  display: 'flex',\n  flexDirection: 'column',\n  justifyContent: 'center',\n  alignItems: 'center',\n  width: '100%',\n  height: '100%'\n});\nconst ProgressTrack = styled.div(({\n  theme\n}) => ({\n  position: 'relative',\n  width: '80%',\n  marginBottom: '0.75rem',\n  maxWidth: 300,\n  height: 5,\n  borderRadius: 5,\n  background: transparentize(0.8, theme.color.secondary),\n  overflow: 'hidden',\n  cursor: 'progress'\n}));\nconst ProgressBar = styled.div(({\n  theme\n}) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  height: '100%',\n  background: theme.color.secondary\n}));\nconst ProgressMessage = styled.div(({\n  theme\n}) => ({\n  minHeight: '2em',\n  fontSize: `${theme.typography.size.s1}px`,\n  color: theme.barTextColor\n}));\nconst ErrorIcon = styled(Icons)(({\n  theme\n}) => ({\n  width: 20,\n  height: 20,\n  marginBottom: '0.5rem',\n  color: theme.color.mediumdark\n}));\nconst ellipsis = keyframes`\n  from { content: \"...\" }\n  33% { content: \".\" }\n  66% { content: \"..\" }\n  to { content: \"...\" }\n`;\nconst Ellipsis = styled.span({\n  '&::after': {\n    content: \"'...'\",\n    animation: `${ellipsis} 1s linear infinite`,\n    animationDelay: '1s',\n    display: 'inline-block',\n    width: '1em',\n    height: 'auto'\n  }\n});\nexport const PureLoader = (_ref) => {\n  let {\n    progress,\n    error,\n    size\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"progress\", \"error\", \"size\"]);\n\n  if (error) {\n    return /*#__PURE__*/React.createElement(ProgressWrapper, _extends({\n      \"aria-label\": error.toString(),\n      \"aria-live\": \"polite\",\n      role: \"status\"\n    }, props), /*#__PURE__*/React.createElement(ErrorIcon, {\n      icon: \"lightningoff\"\n    }), /*#__PURE__*/React.createElement(ProgressMessage, null, error.message));\n  }\n\n  if (progress) {\n    const {\n      value,\n      modules\n    } = progress;\n    let {\n      message\n    } = progress;\n    if (modules) message += ` ${modules.complete} / ${modules.total} modules`;\n    return /*#__PURE__*/React.createElement(ProgressWrapper, _extends({\n      \"aria-label\": \"Content is loading...\",\n      \"aria-live\": \"polite\",\n      \"aria-valuemin\": 0,\n      \"aria-valuemax\": 100,\n      \"aria-valuenow\": value * 100,\n      \"aria-valuetext\": message,\n      role: \"progressbar\"\n    }, props), /*#__PURE__*/React.createElement(ProgressTrack, null, /*#__PURE__*/React.createElement(ProgressBar, {\n      style: {\n        width: `${value * 100}%`\n      }\n    })), /*#__PURE__*/React.createElement(ProgressMessage, null, message, value < 1 && /*#__PURE__*/React.createElement(Ellipsis, {\n      key: message\n    })));\n  }\n\n  return /*#__PURE__*/React.createElement(LoaderWrapper, _extends({\n    \"aria-label\": \"Content is loading...\",\n    \"aria-live\": \"polite\",\n    role: \"status\",\n    size: size\n  }, props));\n};\nPureLoader.displayName = \"PureLoader\";\nexport const Loader = props => {\n  const [progress, setProgress] = useState(undefined);\n  const [error, setError] = useState(undefined);\n  useEffect(() => {\n    // Don't listen for progress updates in static builds\n    // Event source is not defined in IE 11\n    if (CONFIG_TYPE !== 'DEVELOPMENT' || !EventSource) return undefined;\n    const eventSource = new EventSource('/progress');\n    let lastProgress;\n\n    eventSource.onmessage = event => {\n      try {\n        lastProgress = JSON.parse(event.data);\n        setProgress(lastProgress);\n      } catch (e) {\n        setError(e);\n        eventSource.close();\n      }\n    };\n\n    eventSource.onerror = () => {\n      if (lastProgress && lastProgress.value !== 1) setError(new Error('Connection closed'));\n      eventSource.close();\n    };\n\n    return () => eventSource.close();\n  }, []);\n  return /*#__PURE__*/React.createElement(PureLoader, _extends({\n    progress: progress,\n    error: error\n  }, props));\n};\nLoader.displayName = \"Loader\";","import dedent from 'ts-dedent';\nexport class StoryIndexStore {\n  constructor({\n    stories\n  } = {\n    v: 3,\n    stories: {}\n  }) {\n    this.channel = void 0;\n    this.stories = void 0;\n    this.stories = stories;\n  }\n\n  storyIdFromSpecifier(specifier) {\n    const storyIds = Object.keys(this.stories);\n\n    if (specifier === '*') {\n      // '*' means select the first story. If there is none, we have no selection.\n      return storyIds[0];\n    }\n\n    if (typeof specifier === 'string') {\n      // Find the story with the exact id that matches the specifier (see #11571)\n      if (storyIds.indexOf(specifier) >= 0) {\n        return specifier;\n      } // Fallback to the first story that starts with the specifier\n\n\n      return storyIds.find(storyId => storyId.startsWith(specifier));\n    } // Try and find a story matching the name/kind, setting no selection if they don't exist.\n\n\n    const {\n      name,\n      title\n    } = specifier;\n    const match = Object.entries(this.stories).find(([id, story]) => story.name === name && story.title === title);\n    return match && match[0];\n  }\n\n  storyIdToEntry(storyId) {\n    const storyEntry = this.stories[storyId];\n\n    if (!storyEntry) {\n      throw new Error(dedent`Couldn't find story matching '${storyId}' after HMR.\n      - Did you remove it from your CSF file?\n      - Are you sure a story with that id exists?\n      - Please check your stories field of your main.js config.\n      - Also check the browser console and terminal for error messages.`);\n    }\n\n    return storyEntry;\n  }\n\n}","import \"core-js/modules/es.array.reduce.js\";\nimport deepEqual from 'fast-deep-equal';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject';\nimport dedent from 'ts-dedent';\nconst INCOMPATIBLE = Symbol('incompatible');\n\nconst map = (arg, type) => {\n  if (arg === undefined || arg === null || !type) return arg;\n\n  switch (type.name) {\n    case 'string':\n      return String(arg);\n\n    case 'enum':\n      return arg;\n\n    case 'number':\n      return Number(arg);\n\n    case 'boolean':\n      return arg === 'true';\n\n    case 'array':\n      if (!type.value || !Array.isArray(arg)) return INCOMPATIBLE;\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, type.value);\n        if (mapped !== INCOMPATIBLE) acc[index] = mapped;\n        return acc;\n      }, new Array(arg.length));\n\n    case 'object':\n      if (typeof arg === 'string' || typeof arg === 'number') return arg;\n      if (!type.value || typeof arg !== 'object') return INCOMPATIBLE;\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, type.value[key]);\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n          [key]: mapped\n        });\n      }, {});\n\n    default:\n      return INCOMPATIBLE;\n  }\n};\n\nexport const mapArgsToTypes = (args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) return acc;\n    const mapped = map(value, argTypes[key].type);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n      [key]: mapped\n    });\n  }, {});\n};\nexport const combineArgs = (value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce((acc, upd, index) => {\n      acc[index] = combineArgs(value[index], update[index]);\n      return acc;\n    }, [...value]).filter(v => v !== undefined);\n  }\n\n  if (!isPlainObject(value) || !isPlainObject(update)) return update;\n  return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== undefined) acc[key] = combined;\n    } else {\n      acc[key] = value[key];\n    }\n\n    return acc;\n  }, {});\n};\nexport const validateOptions = (args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, {\n    options\n  }]) => {\n    if (!options) {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n\n      return acc;\n    }\n\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    if (options.some(opt => opt && ['object', 'function'].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex(val => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n\n    if (args[key] === undefined || options.includes(args[key]) || isValidArray) {\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map(opt => typeof opt === 'string' ? `'${opt}'` : String(opt)).join(', ');\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}; // TODO -- copied from router, needs to be in a shared location\n\nexport const DEEPLY_EQUAL = Symbol('Deeply equal');\nexport const deepDiff = (value, update) => {\n  if (typeof value !== typeof update) return update;\n  if (deepEqual(value, update)) return DEEPLY_EQUAL;\n\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) acc[index] = diff;\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) return res;\n    return res.concat(new Array(value.length - update.length).fill(undefined));\n  }\n\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n      const diff = deepDiff(value === null || value === void 0 ? void 0 : value[key], update === null || update === void 0 ? void 0 : update[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, {\n        [key]: diff\n      });\n    }, {});\n  }\n\n  return update;\n};\nexport const NO_TARGET_NAME = '';\nexport function groupArgsByTarget({\n  args,\n  argTypes\n}) {\n  const groupedArgs = {};\n  Object.entries(args).forEach(([name, value]) => {\n    const {\n      target = NO_TARGET_NAME\n    } = argTypes[name] || {};\n    groupedArgs[target] = groupedArgs[target] || {};\n    groupedArgs[target][name] = value;\n  });\n  return groupedArgs;\n}\nexport function noTargetArgs(context) {\n  return groupArgsByTarget(context)[NO_TARGET_NAME];\n}","import \"core-js/modules/es.array.reduce.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport { deepDiff, DEEPLY_EQUAL } from './args';\nconst setUndeclaredWarning = deprecate(() => {}, dedent`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `);\nexport class GlobalsStore {\n  constructor() {\n    this.allowedGlobalNames = void 0;\n    this.initialGlobals = void 0;\n    this.globals = {};\n  }\n\n  set({\n    globals = {},\n    globalTypes = {}\n  }) {\n    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = Object.entries(globalTypes).reduce((acc, [key, {\n      defaultValue\n    }]) => {\n      if (defaultValue) acc[key] = defaultValue;\n      return acc;\n    }, {});\n    this.initialGlobals = Object.assign({}, defaultGlobals, globals);\n    this.globals = this.initialGlobals;\n\n    if (delta && delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted); // Note that unlike args, we do not have the same type information for globals to allow us\n    // to type check them here, so we just set them naively\n\n    this.globals = Object.assign({}, this.globals, allowedUrlGlobals);\n  }\n\n  get() {\n    return this.globals;\n  }\n\n  update(newGlobals) {\n    Object.keys(newGlobals).forEach(key => {\n      if (!this.allowedGlobalNames.has(key)) {\n        setUndeclaredWarning();\n      }\n    });\n    this.globals = Object.assign({}, this.globals, newGlobals);\n  }\n\n}","import { storyNameFromExport, toId } from '@storybook/csf';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nimport { normalizeInputTypes } from './normalizeInputTypes';\nconst deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nconst deprecatedStoryAnnotationWarning = deprecate(() => {}, deprecatedStoryAnnotation);\nexport function normalizeStory(key, storyAnnotations, meta) {\n  let userStoryFn;\n  let storyObject;\n\n  if (typeof storyAnnotations === 'function') {\n    userStoryFn = storyAnnotations;\n    storyObject = storyAnnotations;\n  } else {\n    storyObject = storyAnnotations;\n  }\n\n  const {\n    story\n  } = storyObject;\n\n  if (story) {\n    logger.debug('deprecated story', story);\n    deprecatedStoryAnnotationWarning();\n  }\n\n  const exportName = storyNameFromExport(key);\n  const name = typeof storyObject !== 'function' && storyObject.name || storyObject.storyName || (story === null || story === void 0 ? void 0 : story.name) || exportName;\n  const decorators = [...(storyObject.decorators || []), ...((story === null || story === void 0 ? void 0 : story.decorators) || [])];\n  const parameters = Object.assign({}, story === null || story === void 0 ? void 0 : story.parameters, storyObject.parameters);\n  const args = Object.assign({}, story === null || story === void 0 ? void 0 : story.args, storyObject.args);\n  const argTypes = Object.assign({}, story === null || story === void 0 ? void 0 : story.argTypes, storyObject.argTypes);\n  const loaders = [...(storyObject.loaders || []), ...((story === null || story === void 0 ? void 0 : story.loaders) || [])];\n  const {\n    render,\n    play\n  } = storyObject; // eslint-disable-next-line no-underscore-dangle\n\n  const id = parameters.__id || toId(meta.id || meta.title, exportName);\n  return Object.assign({\n    id,\n    name,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders\n  }, render && {\n    render\n  }, userStoryFn && {\n    userStoryFn\n  }, play && {\n    play\n  });\n}","import \"core-js/modules/es.array.reduce.js\";\nimport dedent from 'ts-dedent';\nimport deprecate from 'util-deprecate';\nimport global from 'global';\nimport { combineParameters } from './parameters';\nimport { applyHooks } from './hooks';\nimport { defaultDecorateStory } from './decorators';\nimport { groupArgsByTarget, NO_TARGET_NAME } from './args';\nconst argTypeDefaultValueWarning = deprecate(() => {}, dedent`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`); // Combine all the metadata about a story (both direct and inherited from the component/global scope)\n// into a \"renderable\" story function, with all decorators applied, parameters passed as context etc\n//\n// Note that this story function is *stateless* in the sense that it does not track args or globals\n// Instead, it is expected these are tracked separately (if necessary) and are passed into each invocation.\n\nexport function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  var _global$FEATURES;\n\n  // NOTE: in the current implementation we are doing everything once, up front, rather than doing\n  // anything at render time. The assumption is that as we don't load all the stories at once, this\n  // will have a limited cost. If this proves misguided, we can refactor it.\n  const {\n    id,\n    name\n  } = storyAnnotations;\n  const {\n    title\n  } = componentAnnotations;\n  const parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations.parameters);\n  const decorators = [...(storyAnnotations.decorators || []), ...(componentAnnotations.decorators || []), ...(projectAnnotations.decorators || [])]; // Currently it is only possible to set these globally\n\n  const {\n    applyDecorators = defaultDecorateStory,\n    argTypesEnhancers = [],\n    argsEnhancers = []\n  } = projectAnnotations;\n  const loaders = [...(projectAnnotations.loaders || []), ...(componentAnnotations.loaders || []), ...(storyAnnotations.loaders || [])]; // The render function on annotations *has* to be an `ArgsStoryFn`, so when we normalize\n  // CSFv1/2, we use a new field called `userStoryFn` so we know that it can be a LegacyStoryFn\n\n  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;\n  const passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations.argTypes);\n  const {\n    passArgsFirst = true\n  } = parameters; // eslint-disable-next-line no-underscore-dangle\n\n  parameters.__isArgsStory = passArgsFirst && render.length > 0; // Pull out args[X] into initialArgs for argTypes enhancers\n\n  const passedArgs = Object.assign({}, projectAnnotations.args, componentAnnotations.args, storyAnnotations.args);\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title,\n    kind: title,\n    // Back compat\n    id,\n    name,\n    story: name,\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer(Object.assign({}, contextForEnhancers, {\n    argTypes: accumulatedArgTypes\n  })), contextForEnhancers.argTypes); // Add argTypes[X].defaultValue to initial args (note this deprecated)\n  // We need to do this *after* the argTypesEnhancers as they may add defaultValues\n\n  const defaultArgs = Object.entries(contextForEnhancers.argTypes).reduce((acc, [arg, {\n    defaultValue\n  }]) => {\n    if (typeof defaultValue !== 'undefined') {\n      acc[arg] = defaultValue;\n    }\n\n    return acc;\n  }, {});\n\n  if (Object.keys(defaultArgs).length > 0) {\n    argTypeDefaultValueWarning();\n  }\n\n  const initialArgsBeforeEnhancers = Object.assign({}, defaultArgs, passedArgs);\n  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => Object.assign({}, accumulatedArgs, enhancer(Object.assign({}, contextForEnhancers, {\n    initialArgs: accumulatedArgs\n  }))), initialArgsBeforeEnhancers); // Add some of our metadata into parameters as we used to do this in 6.x and users may be relying on it\n\n  if (!((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.breakingChangesV7)) {\n    contextForEnhancers.parameters = Object.assign({}, contextForEnhancers.parameters, {\n      __id: id,\n      globals: projectAnnotations.globals,\n      globalTypes: projectAnnotations.globalTypes,\n      args: contextForEnhancers.initialArgs,\n      argTypes: contextForEnhancers.argTypes\n    });\n  }\n\n  const applyLoaders = async context => {\n    const loadResults = await Promise.all(loaders.map(loader => loader(context)));\n    const loaded = Object.assign({}, ...loadResults);\n    return Object.assign({}, context, {\n      loaded\n    });\n  };\n\n  const undecoratedStoryFn = context => {\n    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {\n      var _context$argTypes$key;\n\n      const mapping = (_context$argTypes$key = context.argTypes[key]) === null || _context$argTypes$key === void 0 ? void 0 : _context$argTypes$key.mapping;\n      acc[key] = mapping && val in mapping ? mapping[val] : val;\n      return acc;\n    }, {});\n    const mappedContext = Object.assign({}, context, {\n      args: mappedArgs\n    });\n    const {\n      passArgsFirst: renderTimePassArgsFirst = true\n    } = context.parameters;\n    return renderTimePassArgsFirst ? render(mappedContext.args, mappedContext) : render(mappedContext);\n  };\n\n  const decoratedStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n\n  const unboundStoryFn = context => {\n    var _global$FEATURES2;\n\n    let finalContext = context;\n\n    if ((_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.argTypeTargetsV7) {\n      const argsByTarget = groupArgsByTarget(Object.assign({\n        args: context.args\n      }, context));\n      finalContext = Object.assign({}, context, {\n        allArgs: context.args,\n        argsByTarget,\n        args: argsByTarget[NO_TARGET_NAME] || {}\n      });\n    }\n\n    return decoratedStoryFn(finalContext);\n  };\n\n  const playFunction = storyAnnotations.play;\n  return Object.freeze(Object.assign({}, contextForEnhancers, {\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    playFunction\n  }));\n}","import mapValues from 'lodash/mapValues';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport { combineParameters } from './parameters';\n\nconst inferType = (value, name, visited) => {\n  const type = typeof value;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'function':\n    case 'symbol':\n      return {\n        name: type\n      };\n\n    default:\n      break;\n  }\n\n  if (value) {\n    if (visited.has(value)) {\n      logger.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        Consider using the mapping feature or fully custom args:\n        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `);\n      return {\n        name: 'other',\n        value: 'cyclic object'\n      };\n    }\n\n    visited.add(value);\n\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : {\n        name: 'other',\n        value: 'unknown'\n      };\n      return {\n        name: 'array',\n        value: childType\n      };\n    }\n\n    const fieldTypes = mapValues(value, field => inferType(field, name, new Set(visited)));\n    return {\n      name: 'object',\n      value: fieldTypes\n    };\n  }\n\n  return {\n    name: 'object',\n    value: {}\n  };\n};\n\nexport const inferArgTypes = context => {\n  const {\n    id,\n    argTypes: userArgTypes = {},\n    initialArgs = {}\n  } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = true;","import \"core-js/modules/es.array.reduce.js\";\nimport qs from 'qs';\nimport dedent from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport dedent from 'ts-dedent';\nimport qs from 'qs';\nconst {\n  document\n} = global;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nvar Mode;\n\n(function (Mode) {\n  Mode[\"MAIN\"] = \"MAIN\";\n  Mode[\"NOPREVIEW\"] = \"NOPREVIEW\";\n  Mode[\"PREPARING_STORY\"] = \"PREPARING_STORY\";\n  Mode[\"PREPARING_DOCS\"] = \"PREPARING_DOCS\";\n  Mode[\"ERROR\"] = \"ERROR\";\n})(Mode || (Mode = {}));\n\nconst classes = {\n  PREPARING_STORY: 'sb-show-preparing-story',\n  PREPARING_DOCS: 'sb-show-preparing-docs',\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n    this.testing = false;\n    // Special code for testing situations\n    const {\n      __SPECIAL_TEST_PARAMETER__\n    } = qs.parse(document.location.search, {\n      ignoreQueryPrefix: true\n    });\n\n    switch (__SPECIAL_TEST_PARAMETER__) {\n      case 'preparing-story':\n        {\n          this.showPreparingStory();\n          this.testing = true;\n          break;\n        }\n\n      case 'preparing-docs':\n        {\n          this.showPreparingDocs();\n          this.testing = true;\n          break;\n        }\n\n      default: // pass;\n\n    }\n  } // Get ready to render a story, returning the element to render to\n\n\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('docs-root');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showMode(mode) {\n    Object.keys(Mode).forEach(otherMode => {\n      if (otherMode === mode) {\n        document.body.classList.add(classes[otherMode]);\n      } else {\n        document.body.classList.remove(classes[otherMode]);\n      }\n    });\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    let header = message;\n    let detail = stack;\n    const parts = message.split('\\n');\n\n    if (parts.length > 1) {\n      [header] = parts;\n      detail = parts.slice(1).join('\\n');\n    }\n\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(header);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(detail);\n    this.showMode(Mode.ERROR);\n  }\n\n  showNoPreview() {\n    var _this$storyRoot, _this$docsRoot;\n\n    if (this.testing) return;\n    this.showMode(Mode.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    (_this$storyRoot = this.storyRoot()) === null || _this$storyRoot === void 0 ? void 0 : _this$storyRoot.setAttribute('hidden', 'true');\n    (_this$docsRoot = this.docsRoot()) === null || _this$docsRoot === void 0 ? void 0 : _this$docsRoot.setAttribute('hidden', 'true');\n  }\n\n  showPreparingStory() {\n    this.showMode(Mode.PREPARING_STORY);\n  }\n\n  showPreparingDocs() {\n    this.showMode(Mode.PREPARING_DOCS);\n  }\n\n  showMain() {\n    this.showMode(Mode.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n}","import \"core-js/modules/es.array.reduce.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport global from 'global';\nimport { SynchronousPromise } from 'synchronous-promise';\nimport Events, { IGNORED_EXCEPTION } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nconst {\n  window: globalWindow,\n  AbortController,\n  fetch\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nfunction createController() {\n  if (AbortController) return new AbortController(); // Polyfill for IE11\n\n  return {\n    signal: {\n      aborted: false\n    },\n\n    abort() {\n      this.signal.aborted = true;\n    }\n\n  };\n}\n\nconst STORY_INDEX_PATH = './stories.json';\nexport class PreviewWeb {\n  constructor() {\n    var _global$FEATURES;\n\n    this.channel = void 0;\n    this.serverChannel = void 0;\n    this.urlStore = void 0;\n    this.storyStore = void 0;\n    this.view = void 0;\n    this.getStoryIndex = void 0;\n    this.importFn = void 0;\n    this.renderToDOM = void 0;\n    this.previewEntryError = void 0;\n    this.previousSelection = void 0;\n    this.previousStory = void 0;\n    this.previousCleanup = void 0;\n    this.abortController = void 0;\n    this.disableKeyListeners = void 0;\n    this.channel = addons.getChannel();\n\n    if ((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.storyStoreV7 && addons.hasServerChannel()) {\n      this.serverChannel = addons.getServerChannel();\n    }\n\n    this.view = new WebView();\n    this.urlStore = new UrlStore();\n    this.storyStore = new StoryStore(); // Add deprecated APIs for back-compat\n    // @ts-ignore\n\n    this.storyStore.getSelection = deprecate(() => this.urlStore.selection, dedent`\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      `);\n  } // INITIALIZATION\n  // NOTE: the reason that the preview and store's initialization code is written in a promise\n  // style and not `async-await`, and the use of `SynchronousPromise`s is in order to allow\n  // storyshots to immediately call `raw()` on the store without waiting for a later tick.\n  // (Even simple things like `Promise.resolve()` and `await` involve the callback happening\n  // in the next promise \"tick\").\n  // See the comment in `storyshots-core/src/api/index.ts` for more detail.\n\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    // We save these two on initialization in case `getProjectAnnotations` errors,\n    // in which case we may need them later when we recover.\n    this.getStoryIndex = getStoryIndex;\n    this.importFn = importFn;\n    this.setupListeners();\n    return this.getProjectAnnotationsOrRenderError(getProjectAnnotations).then(projectAnnotations => this.initializeWithProjectAnnotations(projectAnnotations));\n  }\n\n  setupListeners() {\n    var _this$serverChannel;\n\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    (_this$serverChannel = this.serverChannel) === null || _this$serverChannel === void 0 ? void 0 : _this$serverChannel.on(Events.STORY_INDEX_INVALIDATED, this.onStoryIndexChanged.bind(this));\n    this.channel.on(Events.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(Events.UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(Events.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(Events.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(Events.RESET_STORY_ARGS, this.onResetArgs.bind(this));\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    return SynchronousPromise.resolve().then(getProjectAnnotations).then(projectAnnotations => {\n      this.renderToDOM = projectAnnotations.renderToDOM;\n\n      if (!this.renderToDOM) {\n        throw new Error(dedent`\n            Expected your framework's preset to export a \\`renderToDOM\\` field.\n\n            Perhaps it needs to be upgraded for Storybook 6.4?\n\n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          `);\n      }\n\n      return projectAnnotations;\n    }).catch(err => {\n      // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n      this.renderPreviewEntryError('Error reading preview.js:', err);\n      throw err;\n    });\n  } // If initialization gets as far as project annotations, this function runs.\n\n\n  initializeWithProjectAnnotations(projectAnnotations) {\n    var _global$FEATURES2;\n\n    this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.setInitialGlobals();\n    let storyIndexPromise;\n\n    if ((_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.storyStoreV7) {\n      storyIndexPromise = this.getStoryIndexFromServer();\n    } else {\n      if (!this.getStoryIndex) {\n        throw new Error('No `getStoryIndex` passed defined in v6 mode');\n      }\n\n      storyIndexPromise = SynchronousPromise.resolve().then(this.getStoryIndex);\n    }\n\n    return storyIndexPromise.then(storyIndex => this.initializeWithStoryIndex(storyIndex)).catch(err => {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    });\n  }\n\n  async setInitialGlobals() {\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.emitGlobals();\n  }\n\n  emitGlobals() {\n    this.channel.emit(Events.SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n  }\n\n  async getStoryIndexFromServer() {\n    const result = await fetch(STORY_INDEX_PATH);\n    if (result.status === 200) return result.json();\n    throw new Error(await result.text());\n  } // If initialization gets as far as the story index, this function runs.\n\n\n  initializeWithStoryIndex(storyIndex) {\n    var _global$FEATURES3;\n\n    return this.storyStore.initialize({\n      storyIndex,\n      importFn: this.importFn,\n      cache: !((_global$FEATURES3 = global.FEATURES) !== null && _global$FEATURES3 !== void 0 && _global$FEATURES3.storyStoreV7)\n    }).then(() => {\n      var _global$FEATURES4;\n\n      if (!((_global$FEATURES4 = global.FEATURES) !== null && _global$FEATURES4 !== void 0 && _global$FEATURES4.storyStoreV7)) {\n        this.channel.emit(Events.SET_STORIES, this.storyStore.getSetStoriesPayload());\n      }\n\n      return this.selectSpecifiedStory();\n    });\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.urlStore.selectionSpecifier) {\n      this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      viewMode,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const storyId = this.storyStore.storyIndex.storyIdFromSpecifier(storySpecifier);\n\n    if (!storyId) {\n      if (storySpecifier === '*') {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find any stories in your Storybook.\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      } else {\n        this.renderStoryLoadingException(storySpecifier, new Error(dedent`\n            Couldn't find story matching '${storySpecifier}'.\n            - Are you sure a story with that id exists?\n            - Please check your stories field of your main.js config.\n            - Also check the browser console and terminal for error messages.\n          `));\n      }\n\n      return;\n    }\n\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(Events.STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  } // EVENT HANDLERS\n  // This happens when a config file gets reloaded\n\n\n  async onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    delete this.previewEntryError;\n    const projectAnnotations = await this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!this.storyStore.projectAnnotations) {\n      await this.initializeWithProjectAnnotations(projectAnnotations);\n      return;\n    }\n\n    await this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.emitGlobals();\n    this.renderSelection();\n  }\n\n  async onStoryIndexChanged() {\n    delete this.previewEntryError;\n\n    if (!this.storyStore.projectAnnotations) {\n      // We haven't successfully set project annotations yet,\n      // we need to do that before we can do anything else.\n      return;\n    }\n\n    try {\n      const storyIndex = await this.getStoryIndexFromServer(); // This is the first time the story index worked, let's load it into the store\n\n      if (!this.storyStore.storyIndex) {\n        await this.initializeWithStoryIndex(storyIndex);\n      } // Update the store with the new stories.\n\n\n      await this.onStoriesChanged({\n        storyIndex\n      });\n    } catch (err) {\n      this.renderPreviewEntryError('Error loading story index:', err);\n      throw err;\n    }\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    var _global$FEATURES5;\n\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (!((_global$FEATURES5 = global.FEATURES) !== null && _global$FEATURES5 !== void 0 && _global$FEATURES5.storyStoreV7)) {\n      this.channel.emit(Events.SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n\n    if (this.urlStore.selection) {\n      await this.renderSelection();\n    } else {\n      // Our selection has never applied before, but maybe it does now, let's try!\n      await this.selectSpecifiedStory();\n    }\n  }\n\n  onKeydown(event) {\n    if (!this.disableKeyListeners && !focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(Events.PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  onSetCurrentStory(selection) {\n    this.urlStore.setSelection(selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateQueryParams(queryParams) {\n    this.urlStore.setQueryParams(queryParams);\n  }\n\n  onUpdateGlobals({\n    globals\n  }) {\n    this.storyStore.globals.update(globals);\n    this.channel.emit(Events.GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    this.channel.emit(Events.STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating the current story's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.previousStory`\n    const {\n      initialArgs\n    } = storyId === this.previousStory.id ? this.previousStory : await this.storyStore.loadStory({\n      storyId\n    });\n    const argNamesToReset = argNames || Object.keys(this.storyStore.args.get(storyId));\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = initialArgs[argName];\n      return acc;\n    }, {});\n    this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  } // RENDERING\n  // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    var _this$previousSelecti, _this$previousSelecti2, _global$FEATURES6;\n\n    const {\n      selection\n    } = this.urlStore;\n\n    if (!selection) {\n      throw new Error('Cannot render story as no selection was made');\n    }\n\n    const {\n      storyId\n    } = selection;\n    const storyIdChanged = ((_this$previousSelecti = this.previousSelection) === null || _this$previousSelecti === void 0 ? void 0 : _this$previousSelecti.storyId) !== storyId;\n    const viewModeChanged = ((_this$previousSelecti2 = this.previousSelection) === null || _this$previousSelecti2 === void 0 ? void 0 : _this$previousSelecti2.viewMode) !== selection.viewMode; // Show a spinner while we load the next story\n\n    if (selection.viewMode === 'story') {\n      this.view.showPreparingStory();\n    } else {\n      this.view.showPreparingDocs();\n    }\n\n    let story;\n\n    try {\n      story = await this.storyStore.loadStory({\n        storyId\n      });\n    } catch (err) {\n      await this.cleanupPreviousRender();\n      this.previousStory = null;\n      this.renderStoryLoadingException(storyId, err);\n      return;\n    }\n\n    const implementationChanged = !storyIdChanged && this.previousStory && story !== this.previousStory;\n\n    if (persistedArgs) {\n      this.storyStore.args.updateFromPersisted(story, persistedArgs);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (this.previousStory && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.channel.emit(Events.STORY_UNCHANGED, storyId);\n      this.view.showMain();\n      return;\n    }\n\n    await this.cleanupPreviousRender({\n      unmountDocs: viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (this.previousSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(Events.STORY_CHANGED, storyId);\n    } // Record the previous selection *before* awaiting the rendering, in cases things change before it is done.\n\n\n    this.previousSelection = selection;\n    this.previousStory = story;\n    const {\n      parameters,\n      initialArgs,\n      argTypes,\n      args\n    } = this.storyStore.getStoryContext(story);\n\n    if ((_global$FEATURES6 = global.FEATURES) !== null && _global$FEATURES6 !== void 0 && _global$FEATURES6.storyStoreV7) {\n      this.channel.emit(Events.STORY_PREPARED, {\n        id: storyId,\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      });\n    } // For v6 mode / compatibility\n    // If the implementation changed, or args were persisted, the args may have changed,\n    // and the STORY_PREPARED event above may not be respected.\n\n\n    if (implementationChanged || persistedArgs) {\n      this.channel.emit(Events.STORY_ARGS_UPDATED, {\n        storyId,\n        args\n      });\n    }\n\n    if (selection.viewMode === 'docs' || story.parameters.docsOnly) {\n      this.previousCleanup = await this.renderDocs({\n        story\n      });\n    } else {\n      this.previousCleanup = this.renderStory({\n        story\n      });\n    }\n  }\n\n  async renderDocs({\n    story\n  }) {\n    var _global$FEATURES8;\n\n    const {\n      id,\n      title,\n      name\n    } = story;\n    const csfFile = await this.storyStore.loadCSFFileByStoryId(id);\n    const docsContext = {\n      id,\n      title,\n      name,\n      // NOTE: these two functions are *sync* so cannot access stories from other CSF files\n      storyById: storyId => this.storyStore.storyFromCSFFile({\n        storyId,\n        csfFile\n      }),\n      componentStories: () => this.storyStore.componentStoriesFromCSFFile({\n        csfFile\n      }),\n      loadStory: storyId => this.storyStore.loadStory({\n        storyId\n      }),\n      renderStoryToElement: this.renderStoryToElement.bind(this),\n      getStoryContext: renderedStory => Object.assign({}, this.storyStore.getStoryContext(renderedStory), {\n        viewMode: 'docs'\n      })\n    };\n\n    const render = async () => {\n      var _global$FEATURES7;\n\n      const fullDocsContext = Object.assign({}, docsContext, !((_global$FEATURES7 = global.FEATURES) !== null && _global$FEATURES7 !== void 0 && _global$FEATURES7.breakingChangesV7) && this.storyStore.getStoryContext(story));\n      const renderer = await import('./renderDocs');\n      const element = this.view.prepareForDocs();\n      renderer.renderDocs(story, fullDocsContext, element, () => this.channel.emit(Events.DOCS_RENDERED, id));\n    }; // Initially render right away\n\n\n    render(); // Listen to events and re-render\n    // NOTE: we aren't checking to see the story args are targetted at the \"right\" story.\n    // This is because we may render >1 story on the page and there is no easy way to keep track\n    // of which ones were rendered by the docs page.\n    // However, in `modernInlineRender`, the individual stories track their own events as they\n    // each call `renderStoryToElement` below.\n\n    if (!((_global$FEATURES8 = global.FEATURES) !== null && _global$FEATURES8 !== void 0 && _global$FEATURES8.modernInlineRender)) {\n      this.channel.on(Events.UPDATE_GLOBALS, render);\n      this.channel.on(Events.UPDATE_STORY_ARGS, render);\n      this.channel.on(Events.RESET_STORY_ARGS, render);\n    }\n\n    return async () => {\n      var _global$FEATURES9;\n\n      if (!((_global$FEATURES9 = global.FEATURES) !== null && _global$FEATURES9 !== void 0 && _global$FEATURES9.modernInlineRender)) {\n        this.channel.off(Events.UPDATE_GLOBALS, render);\n        this.channel.off(Events.UPDATE_STORY_ARGS, render);\n        this.channel.off(Events.RESET_STORY_ARGS, render);\n      }\n    };\n  }\n\n  renderStory({\n    story\n  }) {\n    const element = this.view.prepareForStory(story);\n    const {\n      id,\n      componentId,\n      title,\n      name\n    } = story;\n    const renderContext = {\n      componentId,\n      title,\n      kind: title,\n      id,\n      name,\n      story: name,\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(id, err),\n      showException: err => this.renderException(id, err)\n    };\n    return this.renderStoryToElement({\n      story,\n      renderContext,\n      element,\n      viewMode: 'story'\n    });\n  } // Render a story into a given element and watch for the events that would trigger us\n  // to re-render it (plus deal sensibly with things like changing story mid-way through).\n\n\n  renderStoryToElement({\n    story,\n    renderContext: renderContextWithoutStoryContext,\n    element: canvasElement,\n    viewMode\n  }) {\n    const {\n      id,\n      applyLoaders,\n      unboundStoryFn,\n      playFunction\n    } = story;\n    let notYetRendered = true;\n    let phase;\n\n    const isPending = () => ['rendering', 'playing'].includes(phase);\n\n    this.abortController = createController();\n\n    const render = async ({\n      initial = false,\n      forceRemount = false\n    } = {}) => {\n      if (forceRemount && !initial) {\n        this.abortController.abort();\n        this.abortController = createController();\n      }\n\n      const abortSignal = this.abortController.signal; // we need a stable reference to the signal\n\n      const runPhase = async (phaseName, phaseFn) => {\n        phase = phaseName;\n        this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n          newPhase: phase,\n          storyId: id\n        });\n        if (phaseFn) await phaseFn();\n\n        if (abortSignal.aborted) {\n          phase = 'aborted';\n          this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n            newPhase: phase,\n            storyId: id\n          });\n        }\n      };\n\n      try {\n        let loadedContext;\n        await runPhase('loading', async () => {\n          loadedContext = await applyLoaders(Object.assign({}, this.storyStore.getStoryContext(story), {\n            viewMode\n          }));\n        });\n        if (abortSignal.aborted) return;\n        const renderStoryContext = Object.assign({}, loadedContext, this.storyStore.getStoryContext(story), {\n          abortSignal,\n          canvasElement\n        });\n        const renderContext = Object.assign({}, renderContextWithoutStoryContext, {\n          forceRemount: forceRemount || notYetRendered,\n          storyContext: renderStoryContext,\n          storyFn: () => unboundStoryFn(renderStoryContext),\n          unboundStoryFn\n        });\n        await runPhase('rendering', () => this.renderToDOM(renderContext, canvasElement));\n        notYetRendered = false;\n        if (abortSignal.aborted) return;\n\n        if (forceRemount && playFunction) {\n          this.disableKeyListeners = true;\n          await runPhase('playing', () => playFunction(renderContext.storyContext));\n          await runPhase('played');\n          this.disableKeyListeners = false;\n          if (abortSignal.aborted) return;\n        }\n\n        await runPhase('completed', () => this.channel.emit(Events.STORY_RENDERED, id));\n      } catch (err) {\n        renderContextWithoutStoryContext.showException(err);\n      }\n    }; // Start the first (initial) render. We don't await here because we need to return the \"cleanup\"\n    // function below right away, so if the user changes story during the first render we can cancel\n    // it without having to first wait for it to finish.\n    // Whenever the selection changes we want to force the component to be remounted.\n\n\n    render({\n      initial: true,\n      forceRemount: true\n    });\n\n    const remountStoryIfMatches = ({\n      storyId\n    }) => {\n      if (storyId === story.id) render({\n        forceRemount: true\n      });\n    };\n\n    const rerenderStoryIfMatches = ({\n      storyId\n    }) => {\n      if (storyId === story.id) render();\n    }; // Listen to events and re-render story\n    // Don't forget to unsubscribe on cleanup\n\n\n    this.channel.on(Events.UPDATE_GLOBALS, render);\n    this.channel.on(Events.FORCE_RE_RENDER, render);\n    this.channel.on(Events.FORCE_REMOUNT, remountStoryIfMatches);\n    this.channel.on(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n    this.channel.on(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Cleanup / teardown function invoked on next render (via `cleanupPreviousRender`)\n\n    return async () => {\n      // If the story is torn down (either a new story is rendered or the docs page removes it)\n      // we need to consider the fact that the initial render may not be finished\n      // (possibly the loaders or the play function are still running). We use the controller\n      // as a method to abort them, ASAP, but this is not foolproof as we cannot control what\n      // happens inside the user's code.\n      this.abortController.abort();\n      this.storyStore.cleanupStory(story);\n      this.channel.off(Events.UPDATE_GLOBALS, render);\n      this.channel.off(Events.FORCE_RE_RENDER, render);\n      this.channel.off(Events.FORCE_REMOUNT, remountStoryIfMatches);\n      this.channel.off(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n      this.channel.off(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Check if we're done rendering/playing. If not, we may have to reload the page.\n\n      if (!isPending()) return; // Wait several ticks that may be needed to handle the abort, then try again.\n      // Note that there's a max of 5 nested timeouts before they're no longer \"instant\".\n\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return;\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return;\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return; // If we still haven't completed, reload the page (iframe) to ensure we have a clean slate\n      // for the next render. Since the reload can take a brief moment to happen, we want to stop\n      // further rendering by awaiting a never-resolving promise (which is destroyed on reload).\n\n      global.window.location.reload();\n      await new Promise(() => {});\n    };\n  } // API\n\n\n  async extract(options) {\n    var _global$FEATURES10;\n\n    if (this.previewEntryError) {\n      throw this.previewEntryError;\n    }\n\n    if (!this.storyStore.projectAnnotations) {\n      // In v6 mode, if your preview.js throws, we never get a chance to initialize the preview\n      // or store, and the error is simply logged to the browser console. This is the best we can do\n      throw new Error(dedent`Failed to initialize Storybook.\n      \n      Do you have an error in your \\`preview.js\\`? Check your Storybook's browser console for errors.`);\n    }\n\n    if ((_global$FEATURES10 = global.FEATURES) !== null && _global$FEATURES10 !== void 0 && _global$FEATURES10.storyStoreV7) {\n      await this.storyStore.cacheAllCSFFiles();\n    }\n\n    return this.storyStore.extract(options);\n  } // UTILITIES\n\n\n  async cleanupPreviousRender({\n    unmountDocs = true\n  } = {}) {\n    var _this$previousStory, _this$previousStory$p, _this$previousSelecti3;\n\n    const previousViewMode = (_this$previousStory = this.previousStory) !== null && _this$previousStory !== void 0 && (_this$previousStory$p = _this$previousStory.parameters) !== null && _this$previousStory$p !== void 0 && _this$previousStory$p.docsOnly ? 'docs' : (_this$previousSelecti3 = this.previousSelection) === null || _this$previousSelecti3 === void 0 ? void 0 : _this$previousSelecti3.viewMode;\n\n    if (unmountDocs && previousViewMode === 'docs') {\n      (await import('./renderDocs')).unmountDocs(this.view.docsRoot());\n    }\n\n    if (this.previousCleanup) {\n      await this.previousCleanup();\n    }\n  }\n\n  renderPreviewEntryError(reason, err) {\n    this.previewEntryError = err;\n    logger.error(reason);\n    logger.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(Events.CONFIG_ERROR, err);\n  }\n\n  renderMissingStory() {\n    this.view.showNoPreview();\n    this.channel.emit(Events.STORY_MISSING);\n  }\n\n  renderStoryLoadingException(storySpecifier, err) {\n    logger.error(`Unable to load story '${storySpecifier}':`);\n    logger.error(err);\n    this.view.showErrorDisplay(err);\n    this.channel.emit(Events.STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(storyId, err) {\n    this.channel.emit(Events.STORY_THREW_EXCEPTION, err);\n    this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.\n\n    if (err !== IGNORED_EXCEPTION) {\n      this.view.showErrorDisplay(err);\n      logger.error(`Error rendering story '${storyId}':`);\n      logger.error(err);\n    }\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError(storyId, {\n    title,\n    description\n  }) {\n    logger.error(`Error rendering story ${title}: ${description}`);\n    this.channel.emit(Events.STORY_ERRORED, {\n      title,\n      description\n    });\n    this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import \"core-js/modules/web.immediate.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\n\nconst generateRandomId = () => {\n  // generates a random 13 character string\n  return Math.random().toString(16).slice(2);\n};\n\nexport class Channel {\n  constructor({\n    transport,\n    async = false\n  } = {}) {\n    this.isAsync = void 0;\n    this.sender = generateRandomId();\n    this.events = {};\n    this.data = {};\n    this.transport = void 0;\n    this.addPeerListener = deprecate((eventName, listener) => {\n      this.addListener(eventName, listener);\n    }, dedent`\n      channel.addPeerListener is deprecated\n    `);\n    this.isAsync = async;\n\n    if (transport) {\n      this.transport = transport;\n      this.transport.setHandler(event => this.handleEvent(event));\n    }\n  }\n\n  get hasTransport() {\n    return !!this.transport;\n  }\n\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(listener);\n  }\n\n  emit(eventName, ...args) {\n    const event = {\n      type: eventName,\n      args,\n      from: this.sender\n    };\n    let options = {};\n\n    if (args.length >= 1 && args[0] && args[0].options) {\n      options = args[0].options;\n    }\n\n    const handler = () => {\n      if (this.transport) {\n        this.transport.send(event, options);\n      }\n\n      this.handleEvent(event);\n    };\n\n    if (this.isAsync) {\n      // todo I'm not sure how to test this\n      setImmediate(handler);\n    } else {\n      handler();\n    }\n  }\n\n  last(eventName) {\n    return this.data[eventName];\n  }\n\n  eventNames() {\n    return Object.keys(this.events);\n  }\n\n  listenerCount(eventName) {\n    const listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n\n  listeners(eventName) {\n    const listeners = this.events[eventName];\n    return listeners || undefined;\n  }\n\n  once(eventName, listener) {\n    const onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n\n  removeAllListeners(eventName) {\n    if (!eventName) {\n      this.events = {};\n    } else if (this.events[eventName]) {\n      delete this.events[eventName];\n    }\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this.listeners(eventName);\n\n    if (listeners) {\n      this.events[eventName] = listeners.filter(l => l !== listener);\n    }\n  }\n\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n\n  handleEvent(event) {\n    const listeners = this.listeners(event.type);\n\n    if (listeners && listeners.length) {\n      listeners.forEach(fn => {\n        fn.apply(event, event.args);\n      });\n    }\n\n    this.data[event.type] = event.args;\n  }\n\n  onceListener(eventName, listener) {\n    const onceListener = (...args) => {\n      this.removeListener(eventName, onceListener);\n      return listener(...args);\n    };\n\n    return onceListener;\n  }\n\n}\nexport default Channel;","function _EMOTION_STRINGIFIED_CSS_ERROR__() { return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\"; }\n\nimport { css, keyframes } from '@emotion/core';\nexport const easing = {\n  rubber: 'cubic-bezier(0.175, 0.885, 0.335, 1.05)'\n};\nconst rotate360 = keyframes`\n\tfrom {\n\t\ttransform: rotate(0deg);\n\t}\n\tto {\n\t\ttransform: rotate(360deg);\n\t}\n`;\nconst glow = keyframes`\n  0%, 100% { opacity: 1; }\n  50% { opacity: .4; }\n`;\nconst float = keyframes`\n  0% { transform: translateY(1px); }\n  25% { transform: translateY(0px); }\n  50% { transform: translateY(-3px); }\n  100% { transform: translateY(1px); }\n`;\nconst jiggle = keyframes`\n  0%, 100% { transform:translate3d(0,0,0); }\n  12.5%, 62.5% { transform:translate3d(-4px,0,0); }\n  37.5%, 87.5% {  transform: translate3d(4px,0,0);  }\n`;\nconst inlineGlow = /*#__PURE__*/css(\"animation:\", glow, \" 1.5s ease-in-out infinite;color:transparent;cursor:progress;;label:inlineGlow;\" + (process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbmltYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUNzQiIsImZpbGUiOiIuLi8uLi9zcmMvYW5pbWF0aW9uLnRzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3NzLCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcblxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcbiAgcnViYmVyOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMzUsIDEuMDUpJyxcbn07XG5cbmNvbnN0IHJvdGF0ZTM2MCA9IGtleWZyYW1lc2Bcblx0ZnJvbSB7XG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdH1cblx0dG8ge1xuXHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdH1cbmA7XG5cbmNvbnN0IGdsb3cgPSBrZXlmcmFtZXNgXG4gIDAlLCAxMDAlIHsgb3BhY2l0eTogMTsgfVxuICA1MCUgeyBvcGFjaXR5OiAuNDsgfVxuYDtcblxuY29uc3QgZmxvYXQgPSBrZXlmcmFtZXNgXG4gIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDFweCk7IH1cbiAgMjUlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7IH1cbiAgNTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpOyB9XG4gIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTsgfVxuYDtcblxuY29uc3QgamlnZ2xlID0ga2V5ZnJhbWVzYFxuICAwJSwgMTAwJSB7IHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7IH1cbiAgMTIuNSUsIDYyLjUlIHsgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00cHgsMCwwKTsgfVxuICAzNy41JSwgODcuNSUgeyAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg0cHgsMCwwKTsgIH1cbmA7XG5cbmNvbnN0IGlubGluZUdsb3cgPSBjc3NgXG4gIGFuaW1hdGlvbjogJHtnbG93fSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcHJvZ3Jlc3M7XG5gO1xuXG4vLyBob3ZlciAmIGFjdGl2ZSBzdGF0ZSBmb3IgbGlua3MgYW5kIGJ1dHRvbnNcbmNvbnN0IGhvdmVyYWJsZSA9IGNzc2BcbiAgdHJhbnNpdGlvbjogYWxsIDE1MG1zIGVhc2Utb3V0O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXG4gICY6aG92ZXIge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTJweCwgMCk7XG4gIH1cblxuICAmOmFjdGl2ZSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IHtcbiAgcm90YXRlMzYwLFxuICBnbG93LFxuICBmbG9hdCxcbiAgamlnZ2xlLFxuICBpbmxpbmVHbG93LFxuICBob3ZlcmFibGUsXG59O1xuIl19 */\")); // hover & active state for links and buttons\n\nconst hoverable = process.env.NODE_ENV === \"production\" ? {\n  name: \"1o7rzh8-hoverable\",\n  styles: \"transition:all 150ms ease-out;transform:translate3d(0,0,0);&:hover{transform:translate3d(0,-2px,0);}&:active{transform:translate3d(0,0,0);};label:hoverable;\"\n} : {\n  name: \"1o7rzh8-hoverable\",\n  styles: \"transition:all 150ms ease-out;transform:translate3d(0,0,0);&:hover{transform:translate3d(0,-2px,0);}&:active{transform:translate3d(0,0,0);};label:hoverable;\",\n  map: \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbmltYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0NxQiIsImZpbGUiOiIuLi8uLi9zcmMvYW5pbWF0aW9uLnRzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3NzLCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcblxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcbiAgcnViYmVyOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMzUsIDEuMDUpJyxcbn07XG5cbmNvbnN0IHJvdGF0ZTM2MCA9IGtleWZyYW1lc2Bcblx0ZnJvbSB7XG5cdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdH1cblx0dG8ge1xuXHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdH1cbmA7XG5cbmNvbnN0IGdsb3cgPSBrZXlmcmFtZXNgXG4gIDAlLCAxMDAlIHsgb3BhY2l0eTogMTsgfVxuICA1MCUgeyBvcGFjaXR5OiAuNDsgfVxuYDtcblxuY29uc3QgZmxvYXQgPSBrZXlmcmFtZXNgXG4gIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDFweCk7IH1cbiAgMjUlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7IH1cbiAgNTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpOyB9XG4gIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTsgfVxuYDtcblxuY29uc3QgamlnZ2xlID0ga2V5ZnJhbWVzYFxuICAwJSwgMTAwJSB7IHRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7IH1cbiAgMTIuNSUsIDYyLjUlIHsgdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00cHgsMCwwKTsgfVxuICAzNy41JSwgODcuNSUgeyAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg0cHgsMCwwKTsgIH1cbmA7XG5cbmNvbnN0IGlubGluZUdsb3cgPSBjc3NgXG4gIGFuaW1hdGlvbjogJHtnbG93fSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcHJvZ3Jlc3M7XG5gO1xuXG4vLyBob3ZlciAmIGFjdGl2ZSBzdGF0ZSBmb3IgbGlua3MgYW5kIGJ1dHRvbnNcbmNvbnN0IGhvdmVyYWJsZSA9IGNzc2BcbiAgdHJhbnNpdGlvbjogYWxsIDE1MG1zIGVhc2Utb3V0O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuXG4gICY6aG92ZXIge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTJweCwgMCk7XG4gIH1cblxuICAmOmFjdGl2ZSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IHtcbiAgcm90YXRlMzYwLFxuICBnbG93LFxuICBmbG9hdCxcbiAgamlnZ2xlLFxuICBpbmxpbmVHbG93LFxuICBob3ZlcmFibGUsXG59O1xuIl19 */\",\n  toString: _EMOTION_STRINGIFIED_CSS_ERROR__\n};\nexport const animation = {\n  rotate360,\n  glow,\n  float,\n  jiggle,\n  inlineGlow,\n  hoverable\n};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useContext } from 'react';\nimport { DocsContext } from './DocsContext';\nimport { DocsStory } from './DocsStory';\nimport { Heading } from './Heading';\nexport const Stories = ({\n  title,\n  includePrimary = false\n}) => {\n  const {\n    componentStories\n  } = useContext(DocsContext);\n  let stories = componentStories();\n  if (!includePrimary) stories = stories.slice(1);\n\n  if (!stories || stories.length === 0) {\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Heading, null, title), stories.map(story => story && /*#__PURE__*/React.createElement(DocsStory, _extends({\n    key: story.id\n  }, story, {\n    expanded: true\n  }))));\n};\nStories.defaultProps = {\n  title: 'Stories'\n};","import React, { useContext } from 'react';\nimport global from 'global';\nimport { Anchor } from './Anchor';\nimport { DocsContext } from './DocsContext';\nconst {\n  document\n} = global;\n\nfunction getFirstStoryId(docsContext) {\n  const stories = docsContext.componentStories();\n  return stories.length > 0 ? stories[0].id : null;\n}\n\nfunction renderAnchor() {\n  const context = useContext(DocsContext);\n  const anchorId = getFirstStoryId(context) || context.id;\n  return /*#__PURE__*/React.createElement(Anchor, {\n    storyId: anchorId\n  });\n}\n/**\n * This component is used to declare component metadata in docs\n * and gets transformed into a default export underneath the hood.\n */\n\n\nexport const Meta = () => {\n  const params = new URL(document.location).searchParams;\n  const isDocs = params.get('viewMode') === 'docs';\n  return isDocs ? renderAnchor() : null;\n};","import React from 'react';\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport { ArgsTable } from './ArgsTable';\nimport { CURRENT_SELECTION } from './types';\nexport const Props = deprecate(props => /*#__PURE__*/React.createElement(ArgsTable, props), dedent`\n    Props doc block has been renamed to ArgsTable.\n\n    https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#previewprops-renamed\n  `); // @ts-ignore\n\nProps.defaultProps = {\n  of: CURRENT_SELECTION\n};"],"names":[],"sourceRoot":""}