{"version":3,"file":"917.e7244ada.iframe.bundle.js","mappings":";;AAiBA;;AAEA;;;;;AAQA;ACgCA;;AAEA;;;;;AAQA;AC/CA;;AAEA;;AAIA;;AAUA;;;;AA4DA;;;;AAYA;ACrBA;;;AAIA;AAMA;;;AAIA;;;AC/FA;;;;;ACGA;;;ACKA;ACSA;;;AAIA;;;;ACuCA;ACFA;;;;ACJA;;;;;;;;AAuDA;;AC7FA","sources":["webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/sortStories.js","webpack://origami-storybook/./node_modules/@storybook/builder-webpack5/node_modules/@storybook/client-api/dist/modern/StoryStoreFacade.js","webpack://origami-storybook/./node_modules/@storybook/builder-webpack5/node_modules/@storybook/client-api/dist/modern/ClientApi.js","webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/args.js","webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/GlobalsStore.js","webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/normalizeStory.js","webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/prepareStory.js","webpack://origami-storybook/../../node_modules/@storybook/store/dist/modern/inferArgTypes.js","webpack://origami-storybook/./node_modules/@storybook/react/node_modules/@storybook/core/node_modules/@storybook/core-client/node_modules/@storybook/preview-web/dist/modern/parseArgsParam.js","webpack://origami-storybook/./node_modules/@storybook/react/node_modules/@storybook/core/node_modules/@storybook/core-client/node_modules/@storybook/preview-web/dist/modern/WebView.js","webpack://origami-storybook/./node_modules/@storybook/react/node_modules/@storybook/core/node_modules/@storybook/core-client/node_modules/@storybook/preview-web/dist/modern/PreviewWeb.js","webpack://origami-storybook/../../node_modules/@storybook/channels/dist/modern/index.js"],"sourcesContent":["import stable from 'stable';\nimport dedent from 'ts-dedent';\nimport { storySort } from './storySort';\nexport const sortStoriesV7 = (stories, storySortParameter, fileNameOrder) => {\n  if (storySortParameter) {\n    let sortFn;\n\n    if (typeof storySortParameter === 'function') {\n      sortFn = storySortParameter;\n    } else {\n      sortFn = storySort(storySortParameter);\n    }\n\n    try {\n      stable.inplace(stories, sortFn);\n    } catch (err) {\n      throw new Error(dedent`\n        Error sorting stories with sort parameter ${storySortParameter}:\n\n        > ${err.message}\n        \n        Are you using a V6-style sort function in V7 mode?\n\n        More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n      `);\n    }\n  } else {\n    stable.inplace(stories, (s1, s2) => fileNameOrder.indexOf(s1.importPath) - fileNameOrder.indexOf(s2.importPath));\n  }\n\n  return stories;\n};\n\nconst toIndexEntry = story => {\n  const {\n    id,\n    title,\n    name,\n    parameters\n  } = story;\n  return {\n    id,\n    title,\n    name,\n    importPath: parameters.fileName\n  };\n};\n\nexport const sortStoriesV6 = (stories, storySortParameter, fileNameOrder) => {\n  if (storySortParameter && typeof storySortParameter === 'function') {\n    stable.inplace(stories, storySortParameter);\n    return stories.map(s => toIndexEntry(s[1]));\n  }\n\n  const storiesV7 = stories.map(s => toIndexEntry(s[1]));\n  return sortStoriesV7(storiesV7, storySortParameter, fileNameOrder);\n};","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport \"core-js/modules/es.array.reduce.js\";\nimport global from 'global';\nimport dedent from 'ts-dedent';\nimport { toId, isExportStory, storyNameFromExport } from '@storybook/csf';\nimport { autoTitle, sortStoriesV6 } from '@storybook/store';\nconst {\n  STORIES = []\n} = global;\nexport class StoryStoreFacade {\n  constructor() {\n    this.projectAnnotations = void 0;\n    this.stories = void 0;\n    this.csfExports = void 0;\n    this.projectAnnotations = {\n      loaders: [],\n      decorators: [],\n      parameters: {},\n      argsEnhancers: [],\n      argTypesEnhancers: []\n    };\n    this.stories = {};\n    this.csfExports = {};\n  } // This doesn't actually import anything because the client-api loads fully\n  // on startup, but this is a shim after all.\n\n\n  importFn(path) {\n    const moduleExports = this.csfExports[path];\n    if (!moduleExports) throw new Error(`Unknown path: ${path}`);\n    return moduleExports;\n  }\n\n  getStoryIndex(store) {\n    var _this$projectAnnotati, _this$projectAnnotati2;\n\n    const fileNameOrder = Object.keys(this.csfExports);\n    const storySortParameter = (_this$projectAnnotati = this.projectAnnotations.parameters) === null || _this$projectAnnotati === void 0 ? void 0 : (_this$projectAnnotati2 = _this$projectAnnotati.options) === null || _this$projectAnnotati2 === void 0 ? void 0 : _this$projectAnnotati2.storySort;\n    const storyEntries = Object.entries(this.stories); // Add the kind parameters and global parameters to each entry\n\n    const sortableV6 = storyEntries.map(([storyId, {\n      importPath\n    }]) => {\n      const exports = this.csfExports[importPath];\n      const csfFile = store.processCSFFileWithCache(exports, exports.default.title);\n      return [storyId, store.storyFromCSFFile({\n        storyId,\n        csfFile\n      }), csfFile.meta.parameters, this.projectAnnotations.parameters];\n    }); // NOTE: the sortStoriesV6 version returns the v7 data format. confusing but more convenient!\n\n    let sortedV7;\n\n    try {\n      sortedV7 = sortStoriesV6(sortableV6, storySortParameter, fileNameOrder);\n    } catch (err) {\n      if (typeof storySortParameter === 'function') {\n        throw new Error(dedent`\n          Error sorting stories with sort parameter ${storySortParameter}:\n\n          > ${err.message}\n          \n          Are you using a V7-style sort function in V6 compatibilty mode?\n          \n          More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort\n        `);\n      }\n\n      throw err;\n    }\n\n    const stories = sortedV7.reduce((acc, s) => {\n      // We use the original entry we stored in `this.stories` because it is possible that the CSF file itself\n      // exports a `parameters.fileName` which can be different and mess up our `importFn`.\n      // In fact, in Storyshots there is a Jest transformer that does exactly that.\n      // NOTE: this doesn't actually change the story object, just the index.\n      acc[s.id] = this.stories[s.id];\n      return acc;\n    }, {});\n    return {\n      v: 3,\n      stories\n    };\n  }\n\n  clearFilenameExports(fileName) {\n    if (!this.csfExports[fileName]) {\n      return;\n    } // Clear this module's stories from the storyList and existing exports\n\n\n    Object.entries(this.stories).forEach(([id, {\n      importPath\n    }]) => {\n      if (importPath === fileName) {\n        delete this.stories[id];\n      }\n    }); // We keep this as an empty record so we can use it to maintain component order\n\n    this.csfExports[fileName] = {};\n  } // NOTE: we could potentially share some of this code with the stories.json generation\n\n\n  addStoriesFromExports(fileName, fileExports) {\n    // if the export haven't changed since last time we added them, this is a no-op\n    if (this.csfExports[fileName] === fileExports) {\n      return;\n    } // OTOH, if they have changed, let's clear them out first\n\n\n    this.clearFilenameExports(fileName);\n\n    const {\n      default: defaultExport\n    } = fileExports,\n          namedExports = _objectWithoutPropertiesLoose(fileExports, [\"default\", \"__namedExportsOrder\"]); // eslint-disable-next-line prefer-const\n\n\n    let {\n      id: componentId,\n      title\n    } = defaultExport || {};\n    title = title || autoTitle(fileName, STORIES.map(specifier => Object.assign({}, specifier, {\n      importPathMatcher: new RegExp(specifier.importPathMatcher)\n    })));\n\n    if (!title) {\n      throw new Error(`Unexpected default export without title in '${fileName}': ${JSON.stringify(fileExports.default)}`);\n    }\n\n    this.csfExports[fileName] = Object.assign({}, fileExports, {\n      default: Object.assign({}, defaultExport, {\n        title,\n        parameters: Object.assign({\n          fileName\n        }, defaultExport.parameters)\n      })\n    });\n    Object.entries(namedExports).filter(([key]) => isExportStory(key, defaultExport)).forEach(([key, storyExport]) => {\n      var _storyExport$paramete, _storyExport$story;\n\n      const exportName = storyNameFromExport(key);\n      const id = ((_storyExport$paramete = storyExport.parameters) === null || _storyExport$paramete === void 0 ? void 0 : _storyExport$paramete.__id) || toId(componentId || title, exportName);\n      const name = typeof storyExport !== 'function' && storyExport.name || storyExport.storyName || ((_storyExport$story = storyExport.story) === null || _storyExport$story === void 0 ? void 0 : _storyExport$story.name) || exportName;\n      this.stories[id] = {\n        id,\n        name,\n        title,\n        importPath: fileName\n      };\n    });\n  }\n\n}","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport { toId, sanitize } from '@storybook/csf';\nimport { combineParameters, normalizeInputTypes } from '@storybook/store';\nimport { StoryStoreFacade } from './StoryStoreFacade';\nconst {\n  FEATURES\n} = global;\n// ClientApi (and StoreStore) are really singletons. However they are not created until the\n// relevant framework instanciates them via `start.js`. The good news is this happens right away.\nlet singleton;\nconst warningAlternatives = {\n  addDecorator: `Instead, use \\`export const decorators = [];\\` in your \\`preview.js\\`.`,\n  addParameters: `Instead, use \\`export const parameters = {};\\` in your \\`preview.js\\`.`,\n  addLoaders: `Instead, use \\`export const loaders = [];\\` in your \\`preview.js\\`.`\n};\n\nconst warningMessage = method => deprecate(() => {}, dedent`\n  \\`${method}\\` is deprecated, and will be removed in Storybook 7.0.\n\n  ${warningAlternatives[method]}\n\n  Read more at https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-addparameters-and-adddecorator).`);\n\nconst warnings = {\n  addDecorator: warningMessage('addDecorator'),\n  addParameters: warningMessage('addParameters'),\n  addLoaders: warningMessage('addLoaders')\n};\n\nconst checkMethod = (method, deprecationWarning) => {\n  if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n    throw new Error(dedent`You cannot use \\`${method}\\` with the new Story Store.\n      \n      ${warningAlternatives[method]}`);\n  }\n\n  if (!singleton) {\n    throw new Error(`Singleton client API not yet initialized, cannot call \\`${method}\\`.`);\n  }\n\n  if (deprecationWarning) {\n    warnings[method]();\n  }\n};\n\nexport const addDecorator = (decorator, deprecationWarning = true) => {\n  checkMethod('addDecorator', deprecationWarning);\n  singleton.addDecorator(decorator);\n};\nexport const addParameters = (parameters, deprecationWarning = true) => {\n  checkMethod('addParameters', deprecationWarning);\n  singleton.addParameters(parameters);\n};\nexport const addLoader = (loader, deprecationWarning = true) => {\n  checkMethod('addLoader', deprecationWarning);\n  singleton.addLoader(loader);\n};\nexport const addArgsEnhancer = enhancer => {\n  checkMethod('addArgsEnhancer', false);\n  singleton.addArgsEnhancer(enhancer);\n};\nexport const addArgTypesEnhancer = enhancer => {\n  checkMethod('addArgTypesEnhancer', false);\n  singleton.addArgTypesEnhancer(enhancer);\n};\nexport const getGlobalRender = () => {\n  checkMethod('getGlobalRender', false);\n  return singleton.facade.projectAnnotations.render;\n};\nexport const setGlobalRender = render => {\n  checkMethod('setGlobalRender', false);\n  singleton.facade.projectAnnotations.render = render;\n};\nconst invalidStoryTypes = new Set(['string', 'number', 'boolean', 'symbol']);\nexport class ClientApi {\n  // If we don't get passed modules so don't know filenames, we can\n  // just use numeric indexes\n  constructor({\n    storyStore\n  } = {}) {\n    this.facade = void 0;\n    this.storyStore = void 0;\n    this.addons = void 0;\n    this.onImportFnChanged = void 0;\n    this.lastFileName = 0;\n    this.setAddon = deprecate(addon => {\n      this.addons = Object.assign({}, this.addons, addon);\n    }, dedent`\n      \\`setAddon\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-setaddon\n    `);\n\n    this.addDecorator = decorator => {\n      this.facade.projectAnnotations.decorators.push(decorator);\n    };\n\n    this.clearDecorators = deprecate(() => {\n      this.facade.projectAnnotations.decorators = [];\n    }, dedent`\n      \\`clearDecorators\\` is deprecated and will be removed in Storybook 7.0.\n\n      https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-cleardecorators\n    `);\n\n    this.addParameters = (_ref) => {\n      let {\n        globals,\n        globalTypes\n      } = _ref,\n          parameters = _objectWithoutPropertiesLoose(_ref, [\"globals\", \"globalTypes\"]);\n\n      this.facade.projectAnnotations.parameters = combineParameters(this.facade.projectAnnotations.parameters, parameters);\n\n      if (globals) {\n        this.facade.projectAnnotations.globals = Object.assign({}, this.facade.projectAnnotations.globals, globals);\n      }\n\n      if (globalTypes) {\n        this.facade.projectAnnotations.globalTypes = Object.assign({}, this.facade.projectAnnotations.globalTypes, normalizeInputTypes(globalTypes));\n      }\n    };\n\n    this.addLoader = loader => {\n      this.facade.projectAnnotations.loaders.push(loader);\n    };\n\n    this.addArgsEnhancer = enhancer => {\n      this.facade.projectAnnotations.argsEnhancers.push(enhancer);\n    };\n\n    this.addArgTypesEnhancer = enhancer => {\n      this.facade.projectAnnotations.argTypesEnhancers.push(enhancer);\n    };\n\n    this.storiesOf = (kind, m) => {\n      if (!kind && typeof kind !== 'string') {\n        throw new Error('Invalid or missing kind provided for stories, should be a string');\n      }\n\n      if (!m) {\n        logger.warn(`Missing 'module' parameter for story with a kind of '${kind}'. It will break your HMR`);\n      }\n\n      if (m) {\n        const proto = Object.getPrototypeOf(m);\n\n        if (proto.exports && proto.exports.default) {\n          // FIXME: throw an error in SB6.0\n          logger.error(`Illegal mix of CSF default export and storiesOf calls in a single file: ${proto.i}`);\n        }\n      } // eslint-disable-next-line no-plusplus\n\n\n      const baseFilename = m && m.id ? `${m.id}` : (this.lastFileName++).toString();\n      let fileName = baseFilename;\n      let i = 1; // Deal with `storiesOf()` being called twice in the same file.\n      // On HMR, `this.csfExports[fileName]` will be reset to `{}`, so an empty object is due\n      // to this export, not a second call of `storiesOf()`.\n\n      while (this.facade.csfExports[fileName] && Object.keys(this.facade.csfExports[fileName]).length > 0) {\n        i += 1;\n        fileName = `${baseFilename}-${i}`;\n      }\n\n      if (m && m.hot && m.hot.accept) {\n        // This module used storiesOf(), so when it re-runs on HMR, it will reload\n        // itself automatically without us needing to look at our imports\n        m.hot.accept();\n        m.hot.dispose(() => {\n          this.facade.clearFilenameExports(fileName); // We need to update the importFn as soon as the module re-evaluates\n          // (and calls storiesOf() again, etc). We could call `onImportFnChanged()`\n          // at the end of every setStories call (somehow), but then we'd need to\n          // debounce it somehow for initial startup. Instead, we'll take advantage of\n          // the fact that the evaluation of the module happens immediately in the same tick\n\n          setTimeout(() => {\n            var _this$onImportFnChang;\n\n            (_this$onImportFnChang = this.onImportFnChanged) === null || _this$onImportFnChang === void 0 ? void 0 : _this$onImportFnChang.call(this, {\n              importFn: this.importFn.bind(this)\n            });\n          }, 0);\n        });\n      }\n\n      let hasAdded = false;\n      const api = {\n        kind: kind.toString(),\n        add: () => api,\n        addDecorator: () => api,\n        addLoader: () => api,\n        addParameters: () => api\n      }; // apply addons\n\n      Object.keys(this.addons).forEach(name => {\n        const addon = this.addons[name];\n\n        api[name] = (...args) => {\n          addon.apply(api, args);\n          return api;\n        };\n      });\n      const meta = {\n        id: sanitize(kind),\n        title: kind,\n        decorators: [],\n        loaders: [],\n        parameters: {}\n      }; // We map these back to a simple default export, even though we have type guarantees at this point\n\n      this.facade.csfExports[fileName] = {\n        default: meta\n      };\n      let counter = 0;\n\n      api.add = (storyName, storyFn, parameters = {}) => {\n        hasAdded = true;\n\n        if (typeof storyName !== 'string') {\n          throw new Error(`Invalid or missing storyName provided for a \"${kind}\" story.`);\n        }\n\n        if (!storyFn || Array.isArray(storyFn) || invalidStoryTypes.has(typeof storyFn)) {\n          throw new Error(`Cannot load story \"${storyName}\" in \"${kind}\" due to invalid format. Storybook expected a function/object but received ${typeof storyFn} instead.`);\n        }\n\n        const {\n          decorators,\n          loaders\n        } = parameters,\n              storyParameters = _objectWithoutPropertiesLoose(parameters, [\"decorators\", \"loaders\"]); // eslint-disable-next-line no-underscore-dangle\n\n\n        const storyId = parameters.__id || toId(kind, storyName);\n        const csfExports = this.facade.csfExports[fileName]; // Whack a _ on the front incase it is \"default\"\n\n        csfExports[`story${counter}`] = {\n          name: storyName,\n          parameters: Object.assign({\n            fileName,\n            __id: storyId\n          }, storyParameters),\n          decorators,\n          loaders,\n          render: storyFn\n        };\n        counter += 1;\n        this.facade.stories[storyId] = {\n          id: storyId,\n          title: csfExports.default.title,\n          name: storyName,\n          importPath: fileName\n        };\n        return api;\n      };\n\n      api.addDecorator = decorator => {\n        if (hasAdded) throw new Error(`You cannot add a decorator after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.decorators.push(decorator);\n        return api;\n      };\n\n      api.addLoader = loader => {\n        if (hasAdded) throw new Error(`You cannot add a loader after the first story for a kind.`);\n        meta.loaders.push(loader);\n        return api;\n      };\n\n      api.addParameters = parameters => {\n        if (hasAdded) throw new Error(`You cannot add parameters after the first story for a kind.\nRead more here: https://github.com/storybookjs/storybook/blob/master/MIGRATION.md#can-no-longer-add-decoratorsparameters-after-stories`);\n        meta.parameters = combineParameters(meta.parameters, parameters);\n        return api;\n      };\n\n      return api;\n    };\n\n    this.getStorybook = () => {\n      const {\n        stories\n      } = this.storyStore.storyIndex;\n      const kinds = {};\n      Object.entries(stories).forEach(([storyId, {\n        title,\n        name,\n        importPath\n      }]) => {\n        if (!kinds[title]) {\n          kinds[title] = {\n            kind: title,\n            fileName: importPath,\n            stories: []\n          };\n        }\n\n        const {\n          storyFn\n        } = this.storyStore.fromId(storyId);\n        kinds[title].stories.push({\n          name,\n          render: storyFn\n        });\n      });\n      return Object.values(kinds);\n    };\n\n    this.raw = () => {\n      return this.storyStore.raw();\n    };\n\n    this.facade = new StoryStoreFacade();\n    this.addons = {};\n    this.storyStore = storyStore;\n    singleton = this;\n  }\n\n  importFn(path) {\n    return this.facade.importFn(path);\n  }\n\n  getStoryIndex() {\n    if (!this.storyStore) {\n      throw new Error('Cannot get story index before setting storyStore');\n    }\n\n    return this.facade.getStoryIndex(this.storyStore);\n  }\n\n  // @deprecated\n  get _storyStore() {\n    return this.storyStore;\n  }\n\n}","import \"core-js/modules/es.array.reduce.js\";\nimport deepEqual from 'fast-deep-equal';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject';\nimport dedent from 'ts-dedent';\nconst INCOMPATIBLE = Symbol('incompatible');\n\nconst map = (arg, type) => {\n  if (arg === undefined || arg === null || !type) return arg;\n\n  switch (type.name) {\n    case 'string':\n      return String(arg);\n\n    case 'enum':\n      return arg;\n\n    case 'number':\n      return Number(arg);\n\n    case 'boolean':\n      return arg === 'true';\n\n    case 'array':\n      if (!type.value || !Array.isArray(arg)) return INCOMPATIBLE;\n      return arg.reduce((acc, item, index) => {\n        const mapped = map(item, type.value);\n        if (mapped !== INCOMPATIBLE) acc[index] = mapped;\n        return acc;\n      }, new Array(arg.length));\n\n    case 'object':\n      if (typeof arg === 'string' || typeof arg === 'number') return arg;\n      if (!type.value || typeof arg !== 'object') return INCOMPATIBLE;\n      return Object.entries(arg).reduce((acc, [key, val]) => {\n        const mapped = map(val, type.value[key]);\n        return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n          [key]: mapped\n        });\n      }, {});\n\n    default:\n      return INCOMPATIBLE;\n  }\n};\n\nexport const mapArgsToTypes = (args, argTypes) => {\n  return Object.entries(args).reduce((acc, [key, value]) => {\n    if (!argTypes[key]) return acc;\n    const mapped = map(value, argTypes[key].type);\n    return mapped === INCOMPATIBLE ? acc : Object.assign(acc, {\n      [key]: mapped\n    });\n  }, {});\n};\nexport const combineArgs = (value, update) => {\n  if (Array.isArray(value) && Array.isArray(update)) {\n    return update.reduce((acc, upd, index) => {\n      acc[index] = combineArgs(value[index], update[index]);\n      return acc;\n    }, [...value]).filter(v => v !== undefined);\n  }\n\n  if (!isPlainObject(value) || !isPlainObject(update)) return update;\n  return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n    if (key in update) {\n      const combined = combineArgs(value[key], update[key]);\n      if (combined !== undefined) acc[key] = combined;\n    } else {\n      acc[key] = value[key];\n    }\n\n    return acc;\n  }, {});\n};\nexport const validateOptions = (args, argTypes) => {\n  return Object.entries(argTypes).reduce((acc, [key, {\n    options\n  }]) => {\n    if (!options) {\n      if (key in args) {\n        acc[key] = args[key];\n      }\n\n      return acc;\n    }\n\n    if (!Array.isArray(options)) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should be an array.\n\n        More info: https://storybook.js.org/docs/react/api/argtypes\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    if (options.some(opt => opt && ['object', 'function'].includes(typeof opt))) {\n      once.error(dedent`\n        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.\n\n        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values\n      `);\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const isArray = Array.isArray(args[key]);\n    const invalidIndex = isArray && args[key].findIndex(val => !options.includes(val));\n    const isValidArray = isArray && invalidIndex === -1;\n\n    if (args[key] === undefined || options.includes(args[key]) || isValidArray) {\n      acc[key] = args[key];\n      return acc;\n    }\n\n    const field = isArray ? `${key}[${invalidIndex}]` : key;\n    const supportedOptions = options.map(opt => typeof opt === 'string' ? `'${opt}'` : String(opt)).join(', ');\n    once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`);\n    return acc;\n  }, {});\n}; // TODO -- copied from router, needs to be in a shared location\n\nexport const DEEPLY_EQUAL = Symbol('Deeply equal');\nexport const deepDiff = (value, update) => {\n  if (typeof value !== typeof update) return update;\n  if (deepEqual(value, update)) return DEEPLY_EQUAL;\n\n  if (Array.isArray(value) && Array.isArray(update)) {\n    const res = update.reduce((acc, upd, index) => {\n      const diff = deepDiff(value[index], upd);\n      if (diff !== DEEPLY_EQUAL) acc[index] = diff;\n      return acc;\n    }, new Array(update.length));\n    if (update.length >= value.length) return res;\n    return res.concat(new Array(value.length - update.length).fill(undefined));\n  }\n\n  if (isPlainObject(value) && isPlainObject(update)) {\n    return Object.keys(Object.assign({}, value, update)).reduce((acc, key) => {\n      const diff = deepDiff(value === null || value === void 0 ? void 0 : value[key], update === null || update === void 0 ? void 0 : update[key]);\n      return diff === DEEPLY_EQUAL ? acc : Object.assign(acc, {\n        [key]: diff\n      });\n    }, {});\n  }\n\n  return update;\n};","import \"core-js/modules/es.array.reduce.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport { deepDiff, DEEPLY_EQUAL } from './args';\nconst setUndeclaredWarning = deprecate(() => {}, dedent`\n    Setting a global value that is undeclared (i.e. not in the user's initial set of globals\n    or globalTypes) is deprecated and will have no effect in 7.0.\n  `);\nexport class GlobalsStore {\n  constructor() {\n    this.allowedGlobalNames = void 0;\n    this.initialGlobals = void 0;\n    this.globals = {};\n  }\n\n  set({\n    globals = {},\n    globalTypes = {}\n  }) {\n    const delta = this.initialGlobals && deepDiff(this.initialGlobals, this.globals);\n    this.allowedGlobalNames = new Set([...Object.keys(globals), ...Object.keys(globalTypes)]);\n    const defaultGlobals = Object.entries(globalTypes).reduce((acc, [key, {\n      defaultValue\n    }]) => {\n      if (defaultValue) acc[key] = defaultValue;\n      return acc;\n    }, {});\n    this.initialGlobals = Object.assign({}, defaultGlobals, globals);\n    this.globals = this.initialGlobals;\n\n    if (delta && delta !== DEEPLY_EQUAL) {\n      this.updateFromPersisted(delta);\n    }\n  }\n\n  filterAllowedGlobals(globals) {\n    return Object.entries(globals).reduce((acc, [key, value]) => {\n      if (this.allowedGlobalNames.has(key)) acc[key] = value;\n      return acc;\n    }, {});\n  }\n\n  updateFromPersisted(persisted) {\n    const allowedUrlGlobals = this.filterAllowedGlobals(persisted); // Note that unlike args, we do not have the same type information for globals to allow us\n    // to type check them here, so we just set them naively\n\n    this.globals = Object.assign({}, this.globals, allowedUrlGlobals);\n  }\n\n  get() {\n    return this.globals;\n  }\n\n  update(newGlobals) {\n    Object.keys(newGlobals).forEach(key => {\n      if (!this.allowedGlobalNames.has(key)) {\n        setUndeclaredWarning();\n      }\n    });\n    this.globals = Object.assign({}, this.globals, newGlobals);\n  }\n\n}","import { storyNameFromExport, toId } from '@storybook/csf';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport deprecate from 'util-deprecate';\nimport { normalizeInputTypes } from './normalizeInputTypes';\nconst deprecatedStoryAnnotation = dedent`\nCSF .story annotations deprecated; annotate story functions directly:\n- StoryFn.story.name => StoryFn.storyName\n- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)\nSee https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.\n`;\nconst deprecatedStoryAnnotationWarning = deprecate(() => {}, deprecatedStoryAnnotation);\nexport function normalizeStory(key, storyAnnotations, meta) {\n  let userStoryFn;\n  let storyObject;\n\n  if (typeof storyAnnotations === 'function') {\n    userStoryFn = storyAnnotations;\n    storyObject = storyAnnotations;\n  } else {\n    storyObject = storyAnnotations;\n  }\n\n  const {\n    story\n  } = storyObject;\n\n  if (story) {\n    logger.debug('deprecated story', story);\n    deprecatedStoryAnnotationWarning();\n  }\n\n  const exportName = storyNameFromExport(key);\n  const name = typeof storyObject !== 'function' && storyObject.name || storyObject.storyName || (story === null || story === void 0 ? void 0 : story.name) || exportName;\n  const decorators = [...(storyObject.decorators || []), ...((story === null || story === void 0 ? void 0 : story.decorators) || [])];\n  const parameters = Object.assign({}, story === null || story === void 0 ? void 0 : story.parameters, storyObject.parameters);\n  const args = Object.assign({}, story === null || story === void 0 ? void 0 : story.args, storyObject.args);\n  const argTypes = Object.assign({}, story === null || story === void 0 ? void 0 : story.argTypes, storyObject.argTypes);\n  const loaders = [...(storyObject.loaders || []), ...((story === null || story === void 0 ? void 0 : story.loaders) || [])];\n  const {\n    render,\n    play\n  } = storyObject; // eslint-disable-next-line no-underscore-dangle\n\n  const id = parameters.__id || toId(meta.id || meta.title, exportName);\n  return Object.assign({\n    id,\n    name,\n    decorators,\n    parameters,\n    args,\n    argTypes: normalizeInputTypes(argTypes),\n    loaders\n  }, render && {\n    render\n  }, userStoryFn && {\n    userStoryFn\n  }, play && {\n    play\n  });\n}","import \"core-js/modules/es.array.reduce.js\";\nimport dedent from 'ts-dedent';\nimport deprecate from 'util-deprecate';\nimport global from 'global';\nimport { combineParameters } from './parameters';\nimport { applyHooks } from './hooks';\nimport { defaultDecorateStory } from './decorators';\nconst argTypeDefaultValueWarning = deprecate(() => {}, dedent`\n  \\`argType.defaultValue\\` is deprecated and will be removed in Storybook 7.0.\n\n  https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#no-longer-inferring-default-values-of-args`); // Combine all the metadata about a story (both direct and inherited from the component/global scope)\n// into a \"renderable\" story function, with all decorators applied, parameters passed as context etc\n//\n// Note that this story function is *stateless* in the sense that it does not track args or globals\n// Instead, it is expected these are tracked separately (if necessary) and are passed into each invocation.\n\nexport function prepareStory(storyAnnotations, componentAnnotations, projectAnnotations) {\n  var _global$FEATURES;\n\n  // NOTE: in the current implementation we are doing everything once, up front, rather than doing\n  // anything at render time. The assumption is that as we don't load all the stories at once, this\n  // will have a limited cost. If this proves misguided, we can refactor it.\n  const {\n    id,\n    name\n  } = storyAnnotations;\n  const {\n    title\n  } = componentAnnotations;\n  const parameters = combineParameters(projectAnnotations.parameters, componentAnnotations.parameters, storyAnnotations.parameters);\n  const decorators = [...(storyAnnotations.decorators || []), ...(componentAnnotations.decorators || []), ...(projectAnnotations.decorators || [])]; // Currently it is only possible to set these globally\n\n  const {\n    applyDecorators = defaultDecorateStory,\n    argTypesEnhancers = [],\n    argsEnhancers = []\n  } = projectAnnotations;\n  const loaders = [...(projectAnnotations.loaders || []), ...(componentAnnotations.loaders || []), ...(storyAnnotations.loaders || [])]; // The render function on annotations *has* to be an `ArgsStoryFn`, so when we normalize\n  // CSFv1/2, we use a new field called `userStoryFn` so we know that it can be a LegacyStoryFn\n\n  const render = storyAnnotations.userStoryFn || storyAnnotations.render || componentAnnotations.render || projectAnnotations.render;\n  const passedArgTypes = combineParameters(projectAnnotations.argTypes, componentAnnotations.argTypes, storyAnnotations.argTypes);\n  const {\n    passArgsFirst = true\n  } = parameters; // eslint-disable-next-line no-underscore-dangle\n\n  parameters.__isArgsStory = passArgsFirst && render.length > 0; // Pull out args[X] into initialArgs for argTypes enhancers\n\n  const passedArgs = Object.assign({}, projectAnnotations.args, componentAnnotations.args, storyAnnotations.args);\n  const contextForEnhancers = {\n    componentId: componentAnnotations.id,\n    title,\n    kind: title,\n    // Back compat\n    id,\n    name,\n    story: name,\n    // Back compat\n    component: componentAnnotations.component,\n    subcomponents: componentAnnotations.subcomponents,\n    parameters,\n    initialArgs: passedArgs,\n    argTypes: passedArgTypes\n  };\n  contextForEnhancers.argTypes = argTypesEnhancers.reduce((accumulatedArgTypes, enhancer) => enhancer(Object.assign({}, contextForEnhancers, {\n    argTypes: accumulatedArgTypes\n  })), contextForEnhancers.argTypes); // Add argTypes[X].defaultValue to initial args (note this deprecated)\n  // We need to do this *after* the argTypesEnhancers as they may add defaultValues\n\n  const defaultArgs = Object.entries(contextForEnhancers.argTypes).reduce((acc, [arg, {\n    defaultValue\n  }]) => {\n    if (typeof defaultValue !== 'undefined') {\n      acc[arg] = defaultValue;\n    }\n\n    return acc;\n  }, {});\n\n  if (Object.keys(defaultArgs).length > 0) {\n    argTypeDefaultValueWarning();\n  }\n\n  const initialArgsBeforeEnhancers = Object.assign({}, defaultArgs, passedArgs);\n  contextForEnhancers.initialArgs = argsEnhancers.reduce((accumulatedArgs, enhancer) => Object.assign({}, accumulatedArgs, enhancer(Object.assign({}, contextForEnhancers, {\n    initialArgs: accumulatedArgs\n  }))), initialArgsBeforeEnhancers); // Add some of our metadata into parameters as we used to do this in 6.x and users may be relying on it\n\n  if (!((_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.breakingChangesV7)) {\n    contextForEnhancers.parameters = Object.assign({}, contextForEnhancers.parameters, {\n      __id: id,\n      globals: projectAnnotations.globals,\n      globalTypes: projectAnnotations.globalTypes,\n      args: contextForEnhancers.initialArgs,\n      argTypes: contextForEnhancers.argTypes\n    });\n  }\n\n  const applyLoaders = async context => {\n    const loadResults = await Promise.all(loaders.map(loader => loader(context)));\n    const loaded = Object.assign({}, ...loadResults);\n    return Object.assign({}, context, {\n      loaded\n    });\n  };\n\n  const undecoratedStoryFn = context => {\n    const mappedArgs = Object.entries(context.args).reduce((acc, [key, val]) => {\n      var _context$argTypes$key;\n\n      const mapping = (_context$argTypes$key = context.argTypes[key]) === null || _context$argTypes$key === void 0 ? void 0 : _context$argTypes$key.mapping;\n      acc[key] = mapping && val in mapping ? mapping[val] : val;\n      return acc;\n    }, {});\n    const mappedContext = Object.assign({}, context, {\n      args: mappedArgs\n    });\n    const {\n      passArgsFirst: renderTimePassArgsFirst = true\n    } = context.parameters;\n    return renderTimePassArgsFirst ? render(mappedArgs, mappedContext) : render(mappedContext);\n  };\n\n  const unboundStoryFn = applyHooks(applyDecorators)(undecoratedStoryFn, decorators);\n  const playFunction = storyAnnotations.play;\n  return Object.freeze(Object.assign({}, contextForEnhancers, {\n    originalStoryFn: render,\n    undecoratedStoryFn,\n    unboundStoryFn,\n    applyLoaders,\n    playFunction\n  }));\n}","import mapValues from 'lodash/mapValues';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\nimport { combineParameters } from './parameters';\n\nconst inferType = (value, name, visited) => {\n  const type = typeof value;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'function':\n    case 'symbol':\n      return {\n        name: type\n      };\n\n    default:\n      break;\n  }\n\n  if (value) {\n    if (visited.has(value)) {\n      logger.warn(dedent`\n        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.\n\n        More info: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args\n      `);\n      return {\n        name: 'other',\n        value: 'cyclic object'\n      };\n    }\n\n    visited.add(value);\n\n    if (Array.isArray(value)) {\n      const childType = value.length > 0 ? inferType(value[0], name, new Set(visited)) : {\n        name: 'other',\n        value: 'unknown'\n      };\n      return {\n        name: 'array',\n        value: childType\n      };\n    }\n\n    const fieldTypes = mapValues(value, field => inferType(field, name, new Set(visited)));\n    return {\n      name: 'object',\n      value: fieldTypes\n    };\n  }\n\n  return {\n    name: 'object',\n    value: {}\n  };\n};\n\nexport const inferArgTypes = context => {\n  const {\n    id,\n    argTypes: userArgTypes = {},\n    initialArgs = {}\n  } = context;\n  const argTypes = mapValues(initialArgs, (arg, key) => ({\n    name: key,\n    type: inferType(arg, `${id}.${key}`, new Set())\n  }));\n  const userArgTypesNames = mapValues(userArgTypes, (argType, key) => ({\n    name: key\n  }));\n  return combineParameters(argTypes, userArgTypesNames, userArgTypes);\n};\ninferArgTypes.secondPass = true;","import \"core-js/modules/es.array.reduce.js\";\nimport qs from 'qs';\nimport dedent from 'ts-dedent';\nimport { once } from '@storybook/client-logger';\nimport isPlainObject from 'lodash/isPlainObject'; // Keep this in sync with validateArgs in router/src/utils.ts\n\nconst VALIDATION_REGEXP = /^[a-zA-Z0-9 _-]*$/;\nconst NUMBER_REGEXP = /^-?[0-9]+(\\.[0-9]+)?$/;\nconst HEX_REGEXP = /^#([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i;\nconst COLOR_REGEXP = /^(rgba?|hsla?)\\(([0-9]{1,3}),\\s?([0-9]{1,3})%?,\\s?([0-9]{1,3})%?,?\\s?([0-9](\\.[0-9]{1,2})?)?\\)$/i;\n\nconst validateArgs = (key = '', value) => {\n  if (key === null) return false;\n  if (key === '' || !VALIDATION_REGEXP.test(key)) return false;\n  if (value === null || value === undefined) return true; // encoded as `!null` or `!undefined`\n\n  if (value instanceof Date) return true; // encoded as modified ISO string\n\n  if (typeof value === 'number' || typeof value === 'boolean') return true;\n\n  if (typeof value === 'string') {\n    return VALIDATION_REGEXP.test(value) || NUMBER_REGEXP.test(value) || HEX_REGEXP.test(value) || COLOR_REGEXP.test(value);\n  }\n\n  if (Array.isArray(value)) return value.every(v => validateArgs(key, v));\n  if (isPlainObject(value)) return Object.entries(value).every(([k, v]) => validateArgs(k, v));\n  return false;\n};\n\nconst QS_OPTIONS = {\n  delimiter: ';',\n  // we're parsing a single query param\n  allowDots: true,\n  // objects are encoded using dot notation\n  allowSparse: true,\n\n  // arrays will be merged on top of their initial value\n  decoder(str, defaultDecoder, charset, type) {\n    if (type === 'value' && str.startsWith('!')) {\n      if (str === '!undefined') return undefined;\n      if (str === '!null') return null;\n      if (str.startsWith('!date(') && str.endsWith(')')) return new Date(str.slice(6, -1));\n      if (str.startsWith('!hex(') && str.endsWith(')')) return `#${str.slice(5, -1)}`;\n      const color = str.slice(1).match(COLOR_REGEXP);\n\n      if (color) {\n        if (str.startsWith('!rgba')) return `${color[1]}(${color[2]}, ${color[3]}, ${color[4]}, ${color[5]})`;\n        if (str.startsWith('!hsla')) return `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%, ${color[5]})`;\n        return str.startsWith('!rgb') ? `${color[1]}(${color[2]}, ${color[3]}, ${color[4]})` : `${color[1]}(${color[2]}, ${color[3]}%, ${color[4]}%)`;\n      }\n    }\n\n    if (type === 'value' && NUMBER_REGEXP.test(str)) return Number(str);\n    return defaultDecoder(str, defaultDecoder, charset);\n  }\n\n};\nexport const parseArgsParam = argsString => {\n  const parts = argsString.split(';').map(part => part.replace('=', '~').replace(':', '='));\n  return Object.entries(qs.parse(parts.join(';'), QS_OPTIONS)).reduce((acc, [key, value]) => {\n    if (validateArgs(key, value)) return Object.assign(acc, {\n      [key]: value\n    });\n    once.warn(dedent`\n      Omitted potentially unsafe URL args.\n\n      More info: https://storybook.js.org/docs/react/writing-stories/args#setting-args-through-the-url\n    `);\n    return acc;\n  }, {});\n};","import global from 'global';\nimport { logger } from '@storybook/client-logger';\nimport AnsiToHtml from 'ansi-to-html';\nimport dedent from 'ts-dedent';\nconst {\n  document\n} = global;\nconst layoutClassMap = {\n  centered: 'sb-main-centered',\n  fullscreen: 'sb-main-fullscreen',\n  padded: 'sb-main-padded'\n};\nconst classes = {\n  MAIN: 'sb-show-main',\n  NOPREVIEW: 'sb-show-nopreview',\n  ERROR: 'sb-show-errordisplay'\n};\nconst ansiConverter = new AnsiToHtml({\n  escapeXML: true\n});\nexport class WebView {\n  constructor() {\n    this.currentLayoutClass = void 0;\n  }\n\n  // Get ready to render a story, returning the element to render to\n  prepareForStory(story) {\n    this.showStory();\n    this.applyLayout(story.parameters.layout);\n    document.documentElement.scrollTop = 0;\n    document.documentElement.scrollLeft = 0;\n    return this.storyRoot();\n  }\n\n  storyRoot() {\n    return document.getElementById('root');\n  }\n\n  prepareForDocs() {\n    this.showMain();\n    this.showDocs();\n    this.applyLayout('fullscreen');\n    return this.docsRoot();\n  }\n\n  docsRoot() {\n    return document.getElementById('docs-root');\n  }\n\n  applyLayout(layout = 'padded') {\n    if (layout === 'none') {\n      document.body.classList.remove(this.currentLayoutClass);\n      this.currentLayoutClass = null;\n      return;\n    }\n\n    this.checkIfLayoutExists(layout);\n    const layoutClass = layoutClassMap[layout];\n    document.body.classList.remove(this.currentLayoutClass);\n    document.body.classList.add(layoutClass);\n    this.currentLayoutClass = layoutClass;\n  }\n\n  checkIfLayoutExists(layout) {\n    if (!layoutClassMap[layout]) {\n      logger.warn(dedent`The desired layout: ${layout} is not a valid option.\n         The possible options are: ${Object.keys(layoutClassMap).join(', ')}, none.`);\n    }\n  }\n\n  showErrorDisplay({\n    message = '',\n    stack = ''\n  }) {\n    document.getElementById('error-message').innerHTML = ansiConverter.toHtml(message);\n    document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(stack);\n    document.body.classList.remove(classes.MAIN);\n    document.body.classList.remove(classes.NOPREVIEW);\n    document.body.classList.add(classes.ERROR);\n  }\n\n  showNoPreview() {\n    var _this$storyRoot, _this$docsRoot;\n\n    document.body.classList.remove(classes.MAIN);\n    document.body.classList.remove(classes.ERROR);\n    document.body.classList.add(classes.NOPREVIEW); // In storyshots this can get called and these two can be null\n\n    (_this$storyRoot = this.storyRoot()) === null || _this$storyRoot === void 0 ? void 0 : _this$storyRoot.setAttribute('hidden', 'true');\n    (_this$docsRoot = this.docsRoot()) === null || _this$docsRoot === void 0 ? void 0 : _this$docsRoot.setAttribute('hidden', 'true');\n  }\n\n  showMain() {\n    document.body.classList.remove(classes.NOPREVIEW);\n    document.body.classList.remove(classes.ERROR);\n    document.body.classList.add(classes.MAIN);\n  }\n\n  showDocs() {\n    this.storyRoot().setAttribute('hidden', 'true');\n    this.docsRoot().removeAttribute('hidden');\n  }\n\n  showStory() {\n    this.docsRoot().setAttribute('hidden', 'true');\n    this.storyRoot().removeAttribute('hidden');\n  }\n\n}","import \"core-js/modules/es.array.reduce.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\nimport Events, { IGNORED_EXCEPTION } from '@storybook/core-events';\nimport { logger } from '@storybook/client-logger';\nimport global from 'global';\nimport { addons } from '@storybook/addons';\nimport { StoryStore } from '@storybook/store';\nimport { UrlStore } from './UrlStore';\nimport { WebView } from './WebView';\nimport { StoryIndexClient } from './StoryIndexClient';\nconst {\n  window: globalWindow,\n  AbortController,\n  FEATURES\n} = global;\n\nfunction focusInInput(event) {\n  const target = event.target;\n  return /input|textarea/i.test(target.tagName) || target.getAttribute('contenteditable') !== null;\n}\n\nfunction createController() {\n  if (AbortController) return new AbortController(); // Polyfill for IE11\n\n  return {\n    signal: {\n      aborted: false\n    },\n\n    abort() {\n      this.signal.aborted = true;\n    }\n\n  };\n}\n\nconst INVALIDATE = 'INVALIDATE';\nexport class PreviewWeb {\n  constructor() {\n    this.channel = void 0;\n    this.urlStore = void 0;\n    this.indexClient = void 0;\n    this.storyStore = void 0;\n    this.view = void 0;\n    this.renderToDOM = void 0;\n    this.previousSelection = void 0;\n    this.previousStory = void 0;\n    this.previousCleanup = void 0;\n    this.channel = addons.getChannel();\n    this.view = new WebView();\n    this.urlStore = new UrlStore();\n    this.storyStore = new StoryStore(); // Add deprecated APIs for back-compat\n    // @ts-ignore\n\n    this.storyStore.getSelection = deprecate(() => this.urlStore.selection, dedent`\n        \\`__STORYBOOK_STORY_STORE__.getSelection()\\` is deprecated and will be removed in 7.0.\n  \n        To get the current selection, use the \\`useStoryContext()\\` hook from \\`@storybook/addons\\`.\n      `);\n  }\n\n  initialize({\n    getStoryIndex,\n    importFn,\n    getProjectAnnotations\n  }) {\n    this.storyStore.setProjectAnnotations(this.getProjectAnnotationsOrRenderError(getProjectAnnotations) || {});\n    this.setupListeners();\n\n    if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n      this.indexClient = new StoryIndexClient();\n      return this.indexClient.fetch().then(storyIndex => {\n        this.storyStore.initialize({\n          storyIndex,\n          importFn,\n          cache: false\n        });\n        return this.setGlobalsAndRenderSelection();\n      }).catch(err => {\n        logger.warn(err);\n        this.renderPreviewEntryError(err);\n      });\n    }\n\n    if (!getStoryIndex) {\n      throw new Error('No `getStoryIndex` passed defined in v6 mode');\n    }\n\n    this.storyStore.initialize({\n      storyIndex: getStoryIndex(),\n      importFn,\n      cache: true\n    });\n    this.channel.emit(Events.SET_STORIES, this.storyStore.getSetStoriesPayload());\n    return this.setGlobalsAndRenderSelection();\n  }\n\n  getProjectAnnotationsOrRenderError(getProjectAnnotations) {\n    let projectAnnotations;\n\n    try {\n      projectAnnotations = getProjectAnnotations();\n      this.renderToDOM = projectAnnotations.renderToDOM;\n\n      if (!this.renderToDOM) {\n        throw new Error(dedent`\n            Expected 'framework' in your main.js to export 'renderToDOM', but none found.\n\n            You can fix this automatically by running:\n\n            npx sb@next automigrate\n        \n            More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-framework-field          \n          `);\n      }\n\n      return projectAnnotations;\n    } catch (err) {\n      logger.warn(err); // This is an error extracting the projectAnnotations (i.e. evaluating the previewEntries) and\n      // needs to be show to the user as a simple error\n\n      this.renderPreviewEntryError(err);\n      return undefined;\n    }\n  }\n\n  setupListeners() {\n    globalWindow.onkeydown = this.onKeydown.bind(this);\n    if (this.indexClient) this.indexClient.addEventListener(INVALIDATE, this.onStoryIndexChanged.bind(this));\n    this.channel.on(Events.SET_CURRENT_STORY, this.onSetCurrentStory.bind(this));\n    this.channel.on(Events.UPDATE_QUERY_PARAMS, this.onUpdateQueryParams.bind(this));\n    this.channel.on(Events.UPDATE_GLOBALS, this.onUpdateGlobals.bind(this));\n    this.channel.on(Events.UPDATE_STORY_ARGS, this.onUpdateArgs.bind(this));\n    this.channel.on(Events.RESET_STORY_ARGS, this.onResetArgs.bind(this));\n  }\n\n  async setGlobalsAndRenderSelection() {\n    const {\n      globals\n    } = this.urlStore.selectionSpecifier || {};\n\n    if (globals) {\n      this.storyStore.globals.updateFromPersisted(globals);\n    }\n\n    this.channel.emit(Events.SET_GLOBALS, {\n      globals: this.storyStore.globals.get() || {},\n      globalTypes: this.storyStore.projectAnnotations.globalTypes || {}\n    });\n    return this.selectSpecifiedStory();\n  } // Use the selection specifier to choose a story, then render it\n\n\n  async selectSpecifiedStory() {\n    if (!this.urlStore.selectionSpecifier) {\n      await this.renderMissingStory();\n      return;\n    }\n\n    const {\n      storySpecifier,\n      viewMode,\n      args\n    } = this.urlStore.selectionSpecifier;\n    const storyId = this.storyStore.storyIndex.storyIdFromSpecifier(storySpecifier);\n\n    if (!storyId) {\n      await this.renderMissingStory(storySpecifier);\n      return;\n    }\n\n    this.urlStore.setSelection({\n      storyId,\n      viewMode\n    });\n    this.channel.emit(Events.STORY_SPECIFIED, this.urlStore.selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    await this.renderSelection({\n      persistedArgs: args\n    });\n  }\n\n  onKeydown(event) {\n    if (!focusInInput(event)) {\n      // We have to pick off the keys of the event that we need on the other side\n      const {\n        altKey,\n        ctrlKey,\n        metaKey,\n        shiftKey,\n        key,\n        code,\n        keyCode\n      } = event;\n      this.channel.emit(Events.PREVIEW_KEYDOWN, {\n        event: {\n          altKey,\n          ctrlKey,\n          metaKey,\n          shiftKey,\n          key,\n          code,\n          keyCode\n        }\n      });\n    }\n  }\n\n  onSetCurrentStory(selection) {\n    this.urlStore.setSelection(selection);\n    this.channel.emit(Events.CURRENT_STORY_WAS_SET, this.urlStore.selection);\n    this.renderSelection();\n  }\n\n  onUpdateQueryParams(queryParams) {\n    this.urlStore.setQueryParams(queryParams);\n  }\n\n  onUpdateGlobals({\n    globals\n  }) {\n    this.storyStore.globals.update(globals);\n    this.channel.emit(Events.GLOBALS_UPDATED, {\n      globals: this.storyStore.globals.get(),\n      initialGlobals: this.storyStore.globals.initialGlobals\n    });\n  }\n\n  onUpdateArgs({\n    storyId,\n    updatedArgs\n  }) {\n    this.storyStore.args.update(storyId, updatedArgs);\n    this.channel.emit(Events.STORY_ARGS_UPDATED, {\n      storyId,\n      args: this.storyStore.args.get(storyId)\n    });\n  }\n\n  async onResetArgs({\n    storyId,\n    argNames\n  }) {\n    // NOTE: we have to be careful here and avoid await-ing when updating the current story's args.\n    // That's because below in `renderStoryToElement` we have also bound to this event and will\n    // render the story in the same tick.\n    // However, we can do that safely as the current story is available in `this.previousStory`\n    const {\n      initialArgs\n    } = storyId === this.previousStory.id ? this.previousStory : await this.storyStore.loadStory({\n      storyId\n    });\n    const argNamesToReset = argNames || Object.keys(this.storyStore.args.get(storyId));\n    const updatedArgs = argNamesToReset.reduce((acc, argName) => {\n      acc[argName] = initialArgs[argName];\n      return acc;\n    }, {});\n    this.onUpdateArgs({\n      storyId,\n      updatedArgs\n    });\n  }\n\n  async onStoryIndexChanged() {\n    const storyIndex = await this.indexClient.fetch();\n    return this.onStoriesChanged({\n      storyIndex\n    });\n  } // This happens when a glob gets HMR-ed\n\n\n  async onStoriesChanged({\n    importFn,\n    storyIndex\n  }) {\n    await this.storyStore.onStoriesChanged({\n      importFn,\n      storyIndex\n    });\n\n    if (this.urlStore.selection) {\n      await this.renderSelection();\n    } else {\n      await this.selectSpecifiedStory();\n    }\n\n    if (!(FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7)) {\n      this.channel.emit(Events.SET_STORIES, await this.storyStore.getSetStoriesPayload());\n    }\n  } // This happens when a config file gets reloade\n\n\n  onGetProjectAnnotationsChanged({\n    getProjectAnnotations\n  }) {\n    const projectAnnotations = this.getProjectAnnotationsOrRenderError(getProjectAnnotations);\n\n    if (!projectAnnotations) {\n      return;\n    }\n\n    this.storyStore.setProjectAnnotations(projectAnnotations);\n    this.renderSelection();\n  } // We can either have:\n  // - a story selected in \"story\" viewMode,\n  //     in which case we render it to the root element, OR\n  // - a story selected in \"docs\" viewMode,\n  //     in which case we render the docsPage for that story\n\n\n  async renderSelection({\n    persistedArgs\n  } = {}) {\n    var _this$previousSelecti, _this$previousSelecti2;\n\n    if (!this.urlStore.selection) {\n      throw new Error('Cannot render story as no selection was made');\n    }\n\n    const {\n      selection\n    } = this.urlStore;\n    let story;\n\n    try {\n      story = await this.storyStore.loadStory({\n        storyId: selection.storyId\n      });\n    } catch (err) {\n      this.previousStory = null;\n      logger.warn(err);\n      await this.renderMissingStory(selection.storyId);\n      return;\n    }\n\n    const storyIdChanged = ((_this$previousSelecti = this.previousSelection) === null || _this$previousSelecti === void 0 ? void 0 : _this$previousSelecti.storyId) !== selection.storyId;\n    const viewModeChanged = ((_this$previousSelecti2 = this.previousSelection) === null || _this$previousSelecti2 === void 0 ? void 0 : _this$previousSelecti2.viewMode) !== selection.viewMode;\n    const implementationChanged = !storyIdChanged && this.previousStory && story !== this.previousStory;\n\n    if (persistedArgs) {\n      this.storyStore.args.updateFromPersisted(story, persistedArgs);\n    } // Don't re-render the story if nothing has changed to justify it\n\n\n    if (this.previousStory && !storyIdChanged && !implementationChanged && !viewModeChanged) {\n      this.channel.emit(Events.STORY_UNCHANGED, selection.storyId);\n      return;\n    }\n\n    await this.cleanupPreviousRender({\n      unmountDocs: viewModeChanged\n    }); // If we are rendering something new (as opposed to re-rendering the same or first story), emit\n\n    if (this.previousSelection && (storyIdChanged || viewModeChanged)) {\n      this.channel.emit(Events.STORY_CHANGED, selection.storyId);\n    } // Record the previous selection *before* awaiting the rendering, in cases things change before it is done.\n\n\n    this.previousSelection = selection;\n    this.previousStory = story;\n    const {\n      parameters,\n      initialArgs,\n      argTypes,\n      args\n    } = this.storyStore.getStoryContext(story);\n\n    if (FEATURES !== null && FEATURES !== void 0 && FEATURES.storyStoreV7) {\n      this.channel.emit(Events.STORY_PREPARED, {\n        id: story.id,\n        parameters,\n        initialArgs,\n        argTypes,\n        args\n      });\n    }\n\n    if (selection.viewMode === 'docs' || story.parameters.docsOnly) {\n      this.previousCleanup = await this.renderDocs({\n        story\n      });\n    } else {\n      this.previousCleanup = this.renderStory({\n        story\n      });\n    }\n  }\n\n  async renderDocs({\n    story\n  }) {\n    var _global$FEATURES;\n\n    const {\n      id,\n      title,\n      name\n    } = story;\n    const element = this.view.prepareForDocs();\n    const csfFile = await this.storyStore.loadCSFFileByStoryId(id, {\n      sync: false\n    });\n    const docsContext = {\n      id,\n      title,\n      name,\n      // NOTE: these two functions are *sync* so cannot access stories from other CSF files\n      storyById: storyId => this.storyStore.storyFromCSFFile({\n        storyId,\n        csfFile\n      }),\n      componentStories: () => this.storyStore.componentStoriesFromCSFFile({\n        csfFile\n      }),\n      loadStory: storyId => this.storyStore.loadStory({\n        storyId\n      }),\n      renderStoryToElement: this.renderStoryToElement.bind(this),\n      getStoryContext: renderedStory => Object.assign({}, this.storyStore.getStoryContext(renderedStory), {\n        viewMode: 'docs'\n      })\n    };\n\n    const render = async () => {\n      const fullDocsContext = Object.assign({}, docsContext, !(FEATURES !== null && FEATURES !== void 0 && FEATURES.breakingChangesV7) && this.storyStore.getStoryContext(story));\n      (await import('./renderDocs')).renderDocs(story, fullDocsContext, element, () => this.channel.emit(Events.DOCS_RENDERED, id));\n    }; // Initially render right away\n\n\n    render(); // Listen to events and re-render\n    // NOTE: we aren't checking to see the story args are targetted at the \"right\" story.\n    // This is because we may render >1 story on the page and there is no easy way to keep track\n    // of which ones were rendered by the docs page.\n    // However, in `modernInlineRender`, the individual stories track their own events as they\n    // each call `renderStoryToElement` below.\n\n    if (!(global !== null && global !== void 0 && (_global$FEATURES = global.FEATURES) !== null && _global$FEATURES !== void 0 && _global$FEATURES.modernInlineRender)) {\n      this.channel.on(Events.UPDATE_GLOBALS, render);\n      this.channel.on(Events.UPDATE_STORY_ARGS, render);\n      this.channel.on(Events.RESET_STORY_ARGS, render);\n    }\n\n    return async () => {\n      var _global$FEATURES2;\n\n      if (!(global !== null && global !== void 0 && (_global$FEATURES2 = global.FEATURES) !== null && _global$FEATURES2 !== void 0 && _global$FEATURES2.modernInlineRender)) {\n        this.channel.off(Events.UPDATE_GLOBALS, render);\n        this.channel.off(Events.UPDATE_STORY_ARGS, render);\n        this.channel.off(Events.RESET_STORY_ARGS, render);\n      }\n    };\n  }\n\n  renderStory({\n    story\n  }) {\n    const element = this.view.prepareForStory(story);\n    const {\n      id,\n      componentId,\n      title,\n      name\n    } = story;\n    const renderContext = {\n      componentId,\n      title,\n      kind: title,\n      id,\n      name,\n      story: name,\n      showMain: () => this.view.showMain(),\n      showError: err => this.renderError(id, err),\n      showException: err => this.renderException(id, err)\n    };\n    return this.renderStoryToElement({\n      story,\n      renderContext,\n      element\n    });\n  } // Render a story into a given element and watch for the events that would trigger us\n  // to re-render it (plus deal sensibly with things like changing story mid-way through).\n\n\n  renderStoryToElement({\n    story,\n    renderContext: renderContextWithoutStoryContext,\n    element\n  }) {\n    const {\n      id,\n      applyLoaders,\n      unboundStoryFn,\n      playFunction\n    } = story;\n    let phase;\n\n    const isPending = () => ['rendering', 'playing'].includes(phase);\n\n    let controller;\n    let notYetRendered = true;\n\n    const render = async ({\n      forceRemount = false\n    } = {}) => {\n      let ctrl = controller; // we also need a stable reference within this closure\n      // Abort the signal used by the previous render, so it'll (hopefully) stop executing. The\n      // play function might continue execution regardless, which we deal with during cleanup.\n      // Note we can't reload the page here because there's a legitimate use case for forceRemount\n      // while in the 'playing' phase: the play function may never resolve during debugging, while\n      // \"step back\" will trigger a forceRemount. In this case it's up to the debugger to reload.\n\n      if (ctrl) ctrl.abort();\n      ctrl = createController();\n      controller = ctrl;\n\n      const runPhase = async (phaseName, phaseFn) => {\n        phase = phaseName;\n        this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n          newPhase: phase,\n          storyId: id\n        });\n        await phaseFn();\n\n        if (ctrl.signal.aborted) {\n          phase = 'aborted';\n          this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n            newPhase: phase,\n            storyId: id\n          });\n        }\n      };\n\n      try {\n        let loadedContext;\n        await runPhase('loading', async () => {\n          loadedContext = await applyLoaders(Object.assign({}, this.storyStore.getStoryContext(story), {\n            viewMode: element === this.view.storyRoot() ? 'story' : 'docs'\n          }));\n        });\n        if (ctrl.signal.aborted) return;\n        const renderStoryContext = Object.assign({}, loadedContext, this.storyStore.getStoryContext(story), {\n          abortSignal: ctrl.signal,\n          canvasElement: element\n        });\n        const renderContext = Object.assign({}, renderContextWithoutStoryContext, {\n          forceRemount: forceRemount || notYetRendered,\n          storyContext: renderStoryContext,\n          storyFn: () => unboundStoryFn(renderStoryContext),\n          unboundStoryFn\n        });\n        await runPhase('rendering', () => this.renderToDOM(renderContext, element));\n        notYetRendered = false;\n        if (ctrl.signal.aborted) return;\n\n        if (forceRemount && playFunction) {\n          await runPhase('playing', () => playFunction(renderContext.storyContext));\n          if (ctrl.signal.aborted) return;\n        }\n\n        await runPhase('completed', () => this.channel.emit(Events.STORY_RENDERED, id));\n      } catch (err) {\n        renderContextWithoutStoryContext.showException(err);\n      }\n    }; // Start the first (initial) render. We don't await here because we need to return the \"cleanup\"\n    // function below right away, so if the user changes story during the first render we can cancel\n    // it without having to first wait for it to finish.\n    // Whenever the selection changes we want to force the component to be remounted.\n\n\n    render({\n      forceRemount: true\n    });\n\n    const remountStoryIfMatches = ({\n      storyId\n    }) => {\n      if (storyId === story.id) render({\n        forceRemount: true\n      });\n    };\n\n    const rerenderStoryIfMatches = ({\n      storyId\n    }) => {\n      if (storyId === story.id) render();\n    }; // Listen to events and re-render story\n    // Don't forget to unsubscribe on cleanup\n\n\n    this.channel.on(Events.UPDATE_GLOBALS, render);\n    this.channel.on(Events.FORCE_RE_RENDER, render);\n    this.channel.on(Events.FORCE_REMOUNT, remountStoryIfMatches);\n    this.channel.on(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n    this.channel.on(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Cleanup / teardown function invoked on next render (via `cleanupPreviousRender`)\n\n    return async () => {\n      // If the story is torn down (either a new story is rendered or the docs page removes it)\n      // we need to consider the fact that the initial render may not be finished\n      // (possibly the loaders or the play function are still running). We use the controller\n      // as a method to abort them, ASAP, but this is not foolproof as we cannot control what\n      // happens inside the user's code.\n      controller.abort();\n      this.storyStore.cleanupStory(story);\n      this.channel.off(Events.UPDATE_GLOBALS, render);\n      this.channel.off(Events.FORCE_RE_RENDER, render);\n      this.channel.off(Events.FORCE_REMOUNT, remountStoryIfMatches);\n      this.channel.off(Events.UPDATE_STORY_ARGS, rerenderStoryIfMatches);\n      this.channel.off(Events.RESET_STORY_ARGS, rerenderStoryIfMatches); // Check if we're done rendering/playing. If not, we may have to reload the page.\n\n      if (!isPending()) return; // Wait several ticks that may be needed to handle the abort, then try again.\n      // Note that there's a max of 5 nested timeouts before they're no longer \"instant\".\n\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return;\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return;\n      await new Promise(resolve => setTimeout(resolve, 0));\n      if (!isPending()) return; // If we still haven't completed, reload the page (iframe) to ensure we have a clean slate\n      // for the next render. Since the reload can take a brief moment to happen, we want to stop\n      // further rendering by awaiting a never-resolving promise (which is destroyed on reload).\n\n      global.window.location.reload();\n      await new Promise(() => {});\n    };\n  }\n\n  async cleanupPreviousRender({\n    unmountDocs = true\n  } = {}) {\n    var _this$previousStory, _this$previousStory$p, _this$previousSelecti3;\n\n    const previousViewMode = (_this$previousStory = this.previousStory) !== null && _this$previousStory !== void 0 && (_this$previousStory$p = _this$previousStory.parameters) !== null && _this$previousStory$p !== void 0 && _this$previousStory$p.docsOnly ? 'docs' : (_this$previousSelecti3 = this.previousSelection) === null || _this$previousSelecti3 === void 0 ? void 0 : _this$previousSelecti3.viewMode;\n\n    if (unmountDocs && previousViewMode === 'docs') {\n      (await import('./renderDocs')).unmountDocs(this.view.docsRoot());\n    }\n\n    if (this.previousCleanup) {\n      await this.previousCleanup();\n    }\n  }\n\n  renderPreviewEntryError(err) {\n    this.view.showErrorDisplay(err);\n    this.channel.emit(Events.CONFIG_ERROR, err);\n  }\n\n  async renderMissingStory(storySpecifier) {\n    await this.cleanupPreviousRender();\n    this.view.showNoPreview();\n    this.channel.emit(Events.STORY_MISSING, storySpecifier);\n  } // renderException is used if we fail to render the story and it is uncaught by the app layer\n\n\n  renderException(storyId, error) {\n    this.channel.emit(Events.STORY_THREW_EXCEPTION, error);\n    this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    }); // Ignored exceptions exist for control flow purposes, and are typically handled elsewhere.\n\n    if (error !== IGNORED_EXCEPTION) {\n      this.view.showErrorDisplay(error);\n      logger.error(error);\n    }\n  } // renderError is used by the various app layers to inform the user they have done something\n  // wrong -- for instance returned the wrong thing from a story\n\n\n  renderError(storyId, {\n    title,\n    description\n  }) {\n    this.channel.emit(Events.STORY_ERRORED, {\n      title,\n      description\n    });\n    this.channel.emit(Events.STORY_RENDER_PHASE_CHANGED, {\n      newPhase: 'errored',\n      storyId\n    });\n    this.view.showErrorDisplay({\n      message: title,\n      stack: description\n    });\n  }\n\n}","import \"core-js/modules/web.immediate.js\";\nimport deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\n\nconst generateRandomId = () => {\n  // generates a random 13 character string\n  return Math.random().toString(16).slice(2);\n};\n\nexport class Channel {\n  constructor({\n    transport,\n    async = false\n  } = {}) {\n    this.isAsync = void 0;\n    this.sender = generateRandomId();\n    this.events = {};\n    this.data = {};\n    this.transport = void 0;\n    this.addPeerListener = deprecate((eventName, listener) => {\n      this.addListener(eventName, listener);\n    }, dedent`\n      channel.addPeerListener is deprecated\n    `);\n    this.isAsync = async;\n\n    if (transport) {\n      this.transport = transport;\n      this.transport.setHandler(event => this.handleEvent(event));\n    }\n  }\n\n  get hasTransport() {\n    return !!this.transport;\n  }\n\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(listener);\n  }\n\n  emit(eventName, ...args) {\n    const event = {\n      type: eventName,\n      args,\n      from: this.sender\n    };\n    let options = {};\n\n    if (args.length >= 1 && args[0] && args[0].options) {\n      options = args[0].options;\n    }\n\n    const handler = () => {\n      if (this.transport) {\n        this.transport.send(event, options);\n      }\n\n      this.handleEvent(event);\n    };\n\n    if (this.isAsync) {\n      // todo I'm not sure how to test this\n      setImmediate(handler);\n    } else {\n      handler();\n    }\n  }\n\n  last(eventName) {\n    return this.data[eventName];\n  }\n\n  eventNames() {\n    return Object.keys(this.events);\n  }\n\n  listenerCount(eventName) {\n    const listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n\n  listeners(eventName) {\n    const listeners = this.events[eventName];\n    return listeners || undefined;\n  }\n\n  once(eventName, listener) {\n    const onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n\n  removeAllListeners(eventName) {\n    if (!eventName) {\n      this.events = {};\n    } else if (this.events[eventName]) {\n      delete this.events[eventName];\n    }\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this.listeners(eventName);\n\n    if (listeners) {\n      this.events[eventName] = listeners.filter(l => l !== listener);\n    }\n  }\n\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n\n  handleEvent(event) {\n    const listeners = this.listeners(event.type);\n\n    if (listeners && listeners.length) {\n      listeners.forEach(fn => {\n        fn.apply(event, event.args);\n      });\n    }\n\n    this.data[event.type] = event.args;\n  }\n\n  onceListener(eventName, listener) {\n    const onceListener = (...args) => {\n      this.removeListener(eventName, onceListener);\n      return listener(...args);\n    };\n\n    return onceListener;\n  }\n\n}\nexport default Channel;"],"names":[],"sourceRoot":""}